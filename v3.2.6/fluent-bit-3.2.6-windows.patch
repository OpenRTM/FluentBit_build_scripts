diff -ruN fluent-bit-3.2.6-org/include/fluent-bit/flb_input.h fluent-bit-3.2.6-new/include/fluent-bit/flb_input.h
--- fluent-bit-3.2.6-org/include/fluent-bit/flb_input.h	2025-02-11 05:28:17.000000000 +0900
+++ fluent-bit-3.2.6-new/include/fluent-bit/flb_input.h	2025-02-18 10:54:28.835570700 +0900
@@ -549,9 +549,9 @@
 {
     struct flb_libco_in_params *params;
 
-    params = pthread_getspecific(libco_in_param_key);
+    params = (struct flb_libco_in_params *)pthread_getspecific(libco_in_param_key);
     if (params == NULL) {
-        params = flb_calloc(1, sizeof(struct flb_libco_in_params));
+        params = (struct flb_libco_in_params *)flb_calloc(1, sizeof(struct flb_libco_in_params));
         if (params == NULL) {
             flb_errno();
             return;
@@ -573,9 +573,9 @@
     struct flb_coro *coro;
     struct flb_libco_in_params *params;
 
-    params = pthread_getspecific(libco_in_param_key);
+    params = (struct flb_libco_in_params *)pthread_getspecific(libco_in_param_key);
     if (params == NULL) {
-        params = flb_calloc(1, sizeof(struct flb_libco_in_params));
+        params = (struct flb_libco_in_params *)flb_calloc(1, sizeof(struct flb_libco_in_params));
         if (params == NULL) {
             flb_errno();
             return;
@@ -667,7 +667,7 @@
      * coroutine and passing the input plugin ID that triggered the event.
      */
     val = FLB_BITS_U64_SET(FLB_ENGINE_IN_CORO, ins->id);
-    n = flb_pipe_w(ins->ch_events[1], (void *) &val, sizeof(val));
+    n = flb_pipe_w(ins->ch_events[1], (const char *) &val, sizeof(val));
     if (n == -1) {
         flb_errno();
     }
diff -ruN fluent-bit-3.2.6-org/include/fluent-bit/flb_output.h fluent-bit-3.2.6-new/include/fluent-bit/flb_output.h
--- fluent-bit-3.2.6-org/include/fluent-bit/flb_output.h	2025-02-11 05:28:17.000000000 +0900
+++ fluent-bit-3.2.6-new/include/fluent-bit/flb_output.h	2025-02-18 20:40:00.515273700 +0900
@@ -753,7 +753,7 @@
             }
 
             records = flb_mp_count(p_buf, p_size);
-            tmp = flb_event_chunk_create(evc->type, records, evc->tag, flb_sds_len(evc->tag), p_buf, p_size);
+            tmp = flb_event_chunk_create(evc->type, records, evc->tag, flb_sds_len(evc->tag), (char *)p_buf, p_size);
             if (!tmp) {
                 flb_coro_destroy(coro);
                 flb_free(out_flush);
@@ -822,7 +822,7 @@
                     if ((serialization_buffer_offset +
                          serialized_context_size) > p_size) {
                         resized_serialization_buffer = \
-                            flb_realloc(p_buf, p_size + serialized_context_size);
+                            (char *)flb_realloc(p_buf, p_size + serialized_context_size);
 
                         if (resized_serialization_buffer == NULL) {
                             cmt_encode_msgpack_destroy(serialized_context_buffer);
@@ -860,7 +860,7 @@
                                                 0,
                                                 evc->tag,
                                                 flb_sds_len(evc->tag),
-                                                p_buf,
+                                                (char *)p_buf,
                                                 p_size);
 
             if (out_flush->processed_event_chunk == NULL) {
@@ -919,7 +919,7 @@
                     if ((serialization_buffer_offset +
                          serialized_context_size) > p_size) {
                         resized_serialization_buffer = \
-                            flb_realloc(p_buf, p_size + serialized_context_size);
+                            (char *)flb_realloc(p_buf, p_size + serialized_context_size);
 
                         if (resized_serialization_buffer == NULL) {
                             ctr_encode_msgpack_destroy(serialized_context_buffer);
@@ -957,7 +957,7 @@
                                                 0,
                                                 evc->tag,
                                                 flb_sds_len(evc->tag),
-                                                p_buf,
+                                                (char *)p_buf,
                                                 p_size);
 
             if (out_flush->processed_event_chunk == NULL) {
@@ -1080,7 +1080,7 @@
     }
 
     /* Notify the event loop about our return status */
-    n = flb_pipe_w(pipe_fd, (void *) &val, sizeof(val));
+    n = flb_pipe_w(pipe_fd, (const char *) &val, sizeof(val));
     if (n == -1) {
         flb_errno();
     }
diff -ruN fluent-bit-3.2.6-org/lib/ctraces/lib/mpack/src/mpack/mpack.h fluent-bit-3.2.6-new/lib/ctraces/lib/mpack/src/mpack/mpack.h
--- fluent-bit-3.2.6-org/lib/ctraces/lib/mpack/src/mpack/mpack.h	2025-02-11 05:28:17.000000000 +0900
+++ fluent-bit-3.2.6-new/lib/ctraces/lib/mpack/src/mpack/mpack.h	2025-02-17 17:26:59.055824100 +0900
@@ -3275,120 +3275,120 @@
     mpack_write_i8(writer, value);
 }
 
-MPACK_INLINE void mpack_write(mpack_writer_t* writer, int16_t value) {
-    mpack_write_i16(writer, value);
-}
-
-MPACK_INLINE void mpack_write(mpack_writer_t* writer, int32_t value) {
-    mpack_write_i32(writer, value);
-}
-
-MPACK_INLINE void mpack_write(mpack_writer_t* writer, int64_t value) {
-    mpack_write_i64(writer, value);
-}
-
-MPACK_INLINE void mpack_write(mpack_writer_t* writer, uint8_t value) {
-    mpack_write_u8(writer, value);
-}
-
-MPACK_INLINE void mpack_write(mpack_writer_t* writer, uint16_t value) {
-    mpack_write_u16(writer, value);
-}
-
-MPACK_INLINE void mpack_write(mpack_writer_t* writer, uint32_t value) {
-    mpack_write_u32(writer, value);
-}
-
-MPACK_INLINE void mpack_write(mpack_writer_t* writer, uint64_t value) {
-    mpack_write_u64(writer, value);
-}
-
-MPACK_INLINE void mpack_write(mpack_writer_t* writer, bool value) {
-    mpack_write_bool(writer, value);
-}
-
-MPACK_INLINE void mpack_write(mpack_writer_t* writer, float value) {
-    mpack_write_float(writer, value);
-}
-
-MPACK_INLINE void mpack_write(mpack_writer_t* writer, double value) {
-    mpack_write_double(writer, value);
-}
-
-MPACK_INLINE void mpack_write(mpack_writer_t* writer, char *value) {
-    mpack_write_cstr_or_nil(writer, value);
-}
-
-MPACK_INLINE void mpack_write(mpack_writer_t* writer, const char *value) {
-    mpack_write_cstr_or_nil(writer, value);
-}
-
+//MPACK_INLINE void mpack_write(mpack_writer_t* writer, int16_t value) {
+//    mpack_write_i16(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write(mpack_writer_t* writer, int32_t value) {
+//    mpack_write_i32(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write(mpack_writer_t* writer, int64_t value) {
+//    mpack_write_i64(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write(mpack_writer_t* writer, uint8_t value) {
+//    mpack_write_u8(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write(mpack_writer_t* writer, uint16_t value) {
+//    mpack_write_u16(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write(mpack_writer_t* writer, uint32_t value) {
+//    mpack_write_u32(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write(mpack_writer_t* writer, uint64_t value) {
+//    mpack_write_u64(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write(mpack_writer_t* writer, bool value) {
+//    mpack_write_bool(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write(mpack_writer_t* writer, float value) {
+//    mpack_write_float(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write(mpack_writer_t* writer, double value) {
+//    mpack_write_double(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write(mpack_writer_t* writer, char *value) {
+//    mpack_write_cstr_or_nil(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write(mpack_writer_t* writer, const char *value) {
+//    mpack_write_cstr_or_nil(writer, value);
+//}
+//
 /* C++ generic write for key-value pairs */
-
-MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, int8_t value) {
-    mpack_write_cstr(writer, key);
-    mpack_write_i8(writer, value);
-}
-
-MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, int16_t value) {
-    mpack_write_cstr(writer, key);
-    mpack_write_i16(writer, value);
-}
-
-MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, int32_t value) {
-    mpack_write_cstr(writer, key);
-    mpack_write_i32(writer, value);
-}
-
-MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, int64_t value) {
-    mpack_write_cstr(writer, key);
-    mpack_write_i64(writer, value);
-}
-
-MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, uint8_t value) {
-    mpack_write_cstr(writer, key);
-    mpack_write_u8(writer, value);
-}
-
-MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, uint16_t value) {
-    mpack_write_cstr(writer, key);
-    mpack_write_u16(writer, value);
-}
-
-MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, uint32_t value) {
-    mpack_write_cstr(writer, key);
-    mpack_write_u32(writer, value);
-}
-
-MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, uint64_t value) {
-    mpack_write_cstr(writer, key);
-    mpack_write_u64(writer, value);
-}
-
-MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, bool value) {
-    mpack_write_cstr(writer, key);
-    mpack_write_bool(writer, value);
-}
-
-MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, float value) {
-    mpack_write_cstr(writer, key);
-    mpack_write_float(writer, value);
-}
-
-MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, double value) {
-    mpack_write_cstr(writer, key);
-    mpack_write_double(writer, value);
-}
-
-MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, char *value) {
-    mpack_write_cstr(writer, key);
-    mpack_write_cstr_or_nil(writer, value);
-}
-
-MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, const char *value) {
-    mpack_write_cstr(writer, key);
-    mpack_write_cstr_or_nil(writer, value);
-}
+//
+//MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, int8_t value) {
+//    mpack_write_cstr(writer, key);
+//    mpack_write_i8(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, int16_t value) {
+//    mpack_write_cstr(writer, key);
+//    mpack_write_i16(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, int32_t value) {
+//    mpack_write_cstr(writer, key);
+//    mpack_write_i32(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, int64_t value) {
+//    mpack_write_cstr(writer, key);
+//    mpack_write_i64(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, uint8_t value) {
+//    mpack_write_cstr(writer, key);
+//    mpack_write_u8(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, uint16_t value) {
+//    mpack_write_cstr(writer, key);
+//    mpack_write_u16(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, uint32_t value) {
+//    mpack_write_cstr(writer, key);
+//    mpack_write_u32(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, uint64_t value) {
+//    mpack_write_cstr(writer, key);
+//    mpack_write_u64(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, bool value) {
+//    mpack_write_cstr(writer, key);
+//    mpack_write_bool(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, float value) {
+//    mpack_write_cstr(writer, key);
+//    mpack_write_float(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, double value) {
+//    mpack_write_cstr(writer, key);
+//    mpack_write_double(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, char *value) {
+//    mpack_write_cstr(writer, key);
+//    mpack_write_cstr_or_nil(writer, value);
+//}
+//
+//MPACK_INLINE void mpack_write_kv(mpack_writer_t* writer, const char *key, const char *value) {
+//    mpack_write_cstr(writer, key);
+//    mpack_write_cstr_or_nil(writer, value);
+//}
 
 /**
  * @}
diff -ruN fluent-bit-3.2.6-org/lib/monkey/include/monkey/mk_core/external/winuio.h fluent-bit-3.2.6-new/lib/monkey/include/monkey/mk_core/external/winuio.h
--- fluent-bit-3.2.6-org/lib/monkey/include/monkey/mk_core/external/winuio.h	2025-02-11 05:28:17.000000000 +0900
+++ fluent-bit-3.2.6-new/lib/monkey/include/monkey/mk_core/external/winuio.h	2025-02-17 17:05:33.032118000 +0900
@@ -36,7 +36,8 @@
     for (i = 0; i < iovcnt; i++) {
         int len;
 
-        len = send((SOCKET)fildes, iov[i].iov_base, (int)iov[i].iov_len, 0);
+        len = send((SOCKET)fildes, (const char*)(iov[i].iov_base), (int)iov[i].iov_len, 0);
+
         if (len == SOCKET_ERROR) {
                 uint32_t err = GetLastError();
             // errno = win_to_posix_error(err);
diff -ruN fluent-bit-3.2.6-org/lib/monkey/include/monkey/mk_core/mk_dep_unistd.h fluent-bit-3.2.6-new/lib/monkey/include/monkey/mk_core/mk_dep_unistd.h
--- fluent-bit-3.2.6-org/lib/monkey/include/monkey/mk_core/mk_dep_unistd.h	2025-02-11 05:28:17.000000000 +0900
+++ fluent-bit-3.2.6-new/lib/monkey/include/monkey/mk_core/mk_dep_unistd.h	2025-02-17 17:08:05.244582300 +0900
@@ -44,7 +44,6 @@
 #define STDOUT_FILENO 1
 #define STDERR_FILENO 2
 /* should be in some equivalent to <sys/types.h> */
-typedef __int8            int8_t;
 typedef __int16           int16_t;
 typedef __int32           int32_t;
 typedef __int64           int64_t;
diff -ruN fluent-bit-3.2.6-org/lib/monkey/include/monkey/mk_scheduler.h fluent-bit-3.2.6-new/lib/monkey/include/monkey/mk_scheduler.h
--- fluent-bit-3.2.6-org/lib/monkey/include/monkey/mk_scheduler.h	2025-02-11 05:28:17.000000000 +0900
+++ fluent-bit-3.2.6-new/lib/monkey/include/monkey/mk_scheduler.h	2025-02-18 17:41:09.038726300 +0900
@@ -232,19 +232,19 @@
 
 static inline struct rb_root *mk_sched_get_request_list()
 {
-    return MK_TLS_GET(mk_tls_sched_cs);
+    return (struct rb_root *) MK_TLS_GET(mk_tls_sched_cs);
 }
 
 static inline struct mk_sched_worker *mk_sched_get_thread_conf()
 {
-    return MK_TLS_GET(mk_tls_sched_worker_node);
+    return (struct mk_sched_worker *) MK_TLS_GET(mk_tls_sched_worker_node);
 }
 
 static inline struct mk_event_loop *mk_sched_loop()
 {
     struct mk_sched_worker *w;
 
-    w = MK_TLS_GET(mk_tls_sched_worker_node);
+    w = (struct mk_sched_worker *) MK_TLS_GET(mk_tls_sched_worker_node);
     return w->loop;
 }
 
diff -ruN fluent-bit-3.2.6-org/lib/monkey/include/monkey/mk_stream.h fluent-bit-3.2.6-new/lib/monkey/include/monkey/mk_stream.h
--- fluent-bit-3.2.6-org/lib/monkey/include/monkey/mk_stream.h	2025-02-11 05:28:17.000000000 +0900
+++ fluent-bit-3.2.6-new/lib/monkey/include/monkey/mk_stream.h	2025-02-18 16:52:04.847124900 +0900
@@ -156,7 +156,7 @@
     struct mk_iov *iov;
 
     if (!in) {
-        in = mk_mem_alloc(sizeof(struct mk_stream_input));
+        in = (struct mk_stream_input *) mk_mem_alloc(sizeof(struct mk_stream_input));
         if (!in) {
             return -1;
         }
@@ -175,7 +175,7 @@
     in->stream       = stream;
 
     if (type == MK_STREAM_IOV) {
-        iov = buffer;
+        iov = (struct mk_iov *) buffer;
         in->bytes_total = iov->total_len;
     }
     else {
@@ -272,7 +272,7 @@
      * used by Monkey core, at the moment the only caller is the CGI plugin.
      */
     if (!stream) {
-        stream = mk_mem_alloc(sizeof(struct mk_stream));
+        stream = (struct mk_stream *) mk_mem_alloc(sizeof(struct mk_stream));
         if (!stream) {
             return NULL;
         }
diff -ruN fluent-bit-3.2.6-org/lib/msgpack-c/include/msgpack/pack_template.h fluent-bit-3.2.6-new/lib/msgpack-c/include/msgpack/pack_template.h
--- fluent-bit-3.2.6-org/lib/msgpack-c/include/msgpack/pack_template.h	2025-02-11 05:28:17.000000000 +0900
+++ fluent-bit-3.2.6-new/lib/msgpack-c/include/msgpack/pack_template.h	2025-02-17 15:43:47.045504000 +0900
@@ -1,952 +1,952 @@
-/*
- * MessagePack packing routine template
- *
- * Copyright (C) 2008-2010 FURUHASHI Sadayuki
- *
- *    Distributed under the Boost Software License, Version 1.0.
- *    (See accompanying file LICENSE_1_0.txt or copy at
- *    http://www.boost.org/LICENSE_1_0.txt)
- */
-
-#ifndef MSGPACK_ENDIAN_BIG_BYTE
-#define MSGPACK_ENDIAN_BIG_BYTE 0
-#endif
-#ifndef MSGPACK_ENDIAN_LITTLE_BYTE
-#define MSGPACK_ENDIAN_LITTLE_BYTE 1
-#endif
-
-#if MSGPACK_ENDIAN_LITTLE_BYTE
-#define TAKE8_8(d)  ((uint8_t*)&d)[0]
-#define TAKE8_16(d) ((uint8_t*)&d)[0]
-#define TAKE8_32(d) ((uint8_t*)&d)[0]
-#define TAKE8_64(d) ((uint8_t*)&d)[0]
-#elif MSGPACK_ENDIAN_BIG_BYTE
-#define TAKE8_8(d)  ((uint8_t*)&d)[0]
-#define TAKE8_16(d) ((uint8_t*)&d)[1]
-#define TAKE8_32(d) ((uint8_t*)&d)[3]
-#define TAKE8_64(d) ((uint8_t*)&d)[7]
-#else
-#error msgpack-c supports only big endian and little endian
-#endif
-
-#ifndef msgpack_pack_inline_func
-#error msgpack_pack_inline_func template is not defined
-#endif
-
-#ifndef msgpack_pack_user
-#error msgpack_pack_user type is not defined
-#endif
-
-#ifndef msgpack_pack_append_buffer
-#error msgpack_pack_append_buffer callback is not defined
-#endif
-
-#if defined(_MSC_VER)
-#   pragma warning(push)
-#   pragma warning(disable : 4204)   /* nonstandard extension used: non-constant aggregate initializer */
-#endif
-
-/*
- * Integer
- */
-
-#define msgpack_pack_real_uint8(x, d) \
-do { \
-    if(d < (1<<7)) { \
-        /* fixnum */ \
-        msgpack_pack_append_buffer(x, &TAKE8_8(d), 1); \
-    } else { \
-        /* unsigned 8 */ \
-        unsigned char buf[2] = {0xcc, TAKE8_8(d)}; \
-        msgpack_pack_append_buffer(x, buf, 2); \
-    } \
-} while(0)
-
-#define msgpack_pack_real_uint16(x, d) \
-do { \
-    if(d < (1<<7)) { \
-        /* fixnum */ \
-        msgpack_pack_append_buffer(x, &TAKE8_16(d), 1); \
-    } else if(d < (1<<8)) { \
-        /* unsigned 8 */ \
-        unsigned char buf[2] = {0xcc, TAKE8_16(d)}; \
-        msgpack_pack_append_buffer(x, buf, 2); \
-    } else { \
-        /* unsigned 16 */ \
-        unsigned char buf[3]; \
-        buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
-        msgpack_pack_append_buffer(x, buf, 3); \
-    } \
-} while(0)
-
-#define msgpack_pack_real_uint32(x, d) \
-do { \
-    if(d < (1<<8)) { \
-        if(d < (1<<7)) { \
-            /* fixnum */ \
-            msgpack_pack_append_buffer(x, &TAKE8_32(d), 1); \
-        } else { \
-            /* unsigned 8 */ \
-            unsigned char buf[2] = {0xcc, TAKE8_32(d)}; \
-            msgpack_pack_append_buffer(x, buf, 2); \
-        } \
-    } else { \
-        if(d < (1<<16)) { \
-            /* unsigned 16 */ \
-            unsigned char buf[3]; \
-            buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
-            msgpack_pack_append_buffer(x, buf, 3); \
-        } else { \
-            /* unsigned 32 */ \
-            unsigned char buf[5]; \
-            buf[0] = 0xce; _msgpack_store32(&buf[1], (uint32_t)d); \
-            msgpack_pack_append_buffer(x, buf, 5); \
-        } \
-    } \
-} while(0)
-
-#define msgpack_pack_real_uint64(x, d) \
-do { \
-    if(d < (1ULL<<8)) { \
-        if(d < (1ULL<<7)) { \
-            /* fixnum */ \
-            msgpack_pack_append_buffer(x, &TAKE8_64(d), 1); \
-        } else { \
-            /* unsigned 8 */ \
-            unsigned char buf[2] = {0xcc, TAKE8_64(d)}; \
-            msgpack_pack_append_buffer(x, buf, 2); \
-        } \
-    } else { \
-        if(d < (1ULL<<16)) { \
-            /* unsigned 16 */ \
-            unsigned char buf[3]; \
-            buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
-            msgpack_pack_append_buffer(x, buf, 3); \
-        } else if(d < (1ULL<<32)) { \
-            /* unsigned 32 */ \
-            unsigned char buf[5]; \
-            buf[0] = 0xce; _msgpack_store32(&buf[1], (uint32_t)d); \
-            msgpack_pack_append_buffer(x, buf, 5); \
-        } else { \
-            /* unsigned 64 */ \
-            unsigned char buf[9]; \
-            buf[0] = 0xcf; _msgpack_store64(&buf[1], d); \
-            msgpack_pack_append_buffer(x, buf, 9); \
-        } \
-    } \
-} while(0)
-
-#define msgpack_pack_real_int8(x, d) \
-do { \
-    if(d < -(1<<5)) { \
-        /* signed 8 */ \
-        unsigned char buf[2] = {0xd0, TAKE8_8(d)}; \
-        msgpack_pack_append_buffer(x, buf, 2); \
-    } else { \
-        /* fixnum */ \
-        msgpack_pack_append_buffer(x, &TAKE8_8(d), 1); \
-    } \
-} while(0)
-
-#define msgpack_pack_real_int16(x, d) \
-do { \
-    if(d < -(1<<5)) { \
-        if(d < -(1<<7)) { \
-            /* signed 16 */ \
-            unsigned char buf[3]; \
-            buf[0] = 0xd1; _msgpack_store16(&buf[1], (int16_t)d); \
-            msgpack_pack_append_buffer(x, buf, 3); \
-        } else { \
-            /* signed 8 */ \
-            unsigned char buf[2] = {0xd0, TAKE8_16(d)}; \
-            msgpack_pack_append_buffer(x, buf, 2); \
-        } \
-    } else if(d < (1<<7)) { \
-        /* fixnum */ \
-        msgpack_pack_append_buffer(x, &TAKE8_16(d), 1); \
-    } else { \
-        if(d < (1<<8)) { \
-            /* unsigned 8 */ \
-            unsigned char buf[2] = {0xcc, TAKE8_16(d)}; \
-            msgpack_pack_append_buffer(x, buf, 2); \
-        } else { \
-            /* unsigned 16 */ \
-            unsigned char buf[3]; \
-            buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
-            msgpack_pack_append_buffer(x, buf, 3); \
-        } \
-    } \
-} while(0)
-
-#define msgpack_pack_real_int32(x, d) \
-do { \
-    if(d < -(1<<5)) { \
-        if(d < -(1<<15)) { \
-            /* signed 32 */ \
-            unsigned char buf[5]; \
-            buf[0] = 0xd2; _msgpack_store32(&buf[1], (int32_t)d); \
-            msgpack_pack_append_buffer(x, buf, 5); \
-        } else if(d < -(1<<7)) { \
-            /* signed 16 */ \
-            unsigned char buf[3]; \
-            buf[0] = 0xd1; _msgpack_store16(&buf[1], (int16_t)d); \
-            msgpack_pack_append_buffer(x, buf, 3); \
-        } else { \
-            /* signed 8 */ \
-            unsigned char buf[2] = {0xd0, TAKE8_32(d)}; \
-            msgpack_pack_append_buffer(x, buf, 2); \
-        } \
-    } else if(d < (1<<7)) { \
-        /* fixnum */ \
-        msgpack_pack_append_buffer(x, &TAKE8_32(d), 1); \
-    } else { \
-        if(d < (1<<8)) { \
-            /* unsigned 8 */ \
-            unsigned char buf[2] = {0xcc, TAKE8_32(d)}; \
-            msgpack_pack_append_buffer(x, buf, 2); \
-        } else if(d < (1<<16)) { \
-            /* unsigned 16 */ \
-            unsigned char buf[3]; \
-            buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
-            msgpack_pack_append_buffer(x, buf, 3); \
-        } else { \
-            /* unsigned 32 */ \
-            unsigned char buf[5]; \
-            buf[0] = 0xce; _msgpack_store32(&buf[1], (uint32_t)d); \
-            msgpack_pack_append_buffer(x, buf, 5); \
-        } \
-    } \
-} while(0)
-
-#define msgpack_pack_real_int64(x, d) \
-do { \
-    if(d < -(1LL<<5)) { \
-        if(d < -(1LL<<15)) { \
-            if(d < -(1LL<<31)) { \
-                /* signed 64 */ \
-                unsigned char buf[9]; \
-                buf[0] = 0xd3; _msgpack_store64(&buf[1], d); \
-                msgpack_pack_append_buffer(x, buf, 9); \
-            } else { \
-                /* signed 32 */ \
-                unsigned char buf[5]; \
-                buf[0] = 0xd2; _msgpack_store32(&buf[1], (int32_t)d); \
-                msgpack_pack_append_buffer(x, buf, 5); \
-            } \
-        } else { \
-            if(d < -(1<<7)) { \
-                /* signed 16 */ \
-                unsigned char buf[3]; \
-                buf[0] = 0xd1; _msgpack_store16(&buf[1], (int16_t)d); \
-                msgpack_pack_append_buffer(x, buf, 3); \
-            } else { \
-                /* signed 8 */ \
-                unsigned char buf[2] = {0xd0, TAKE8_64(d)}; \
-                msgpack_pack_append_buffer(x, buf, 2); \
-            } \
-        } \
-    } else if(d < (1<<7)) { \
-        /* fixnum */ \
-        msgpack_pack_append_buffer(x, &TAKE8_64(d), 1); \
-    } else { \
-        if(d < (1LL<<16)) { \
-            if(d < (1<<8)) { \
-                /* unsigned 8 */ \
-                unsigned char buf[2] = {0xcc, TAKE8_64(d)}; \
-                msgpack_pack_append_buffer(x, buf, 2); \
-            } else { \
-                /* unsigned 16 */ \
-                unsigned char buf[3]; \
-                buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
-                msgpack_pack_append_buffer(x, buf, 3); \
-            } \
-        } else { \
-            if(d < (1LL<<32)) { \
-                /* unsigned 32 */ \
-                unsigned char buf[5]; \
-                buf[0] = 0xce; _msgpack_store32(&buf[1], (uint32_t)d); \
-                msgpack_pack_append_buffer(x, buf, 5); \
-            } else { \
-                /* unsigned 64 */ \
-                unsigned char buf[9]; \
-                buf[0] = 0xcf; _msgpack_store64(&buf[1], d); \
-                msgpack_pack_append_buffer(x, buf, 9); \
-            } \
-        } \
-    } \
-} while(0)
-
-
-#ifdef msgpack_pack_inline_func_fixint
-
-msgpack_pack_inline_func_fixint(_uint8)(msgpack_pack_user x, uint8_t d)
-{
-    unsigned char buf[2] = {0xcc, TAKE8_8(d)};
-    msgpack_pack_append_buffer(x, buf, 2);
-}
-
-msgpack_pack_inline_func_fixint(_uint16)(msgpack_pack_user x, uint16_t d)
-{
-    unsigned char buf[3];
-    buf[0] = 0xcd; _msgpack_store16(&buf[1], d);
-    msgpack_pack_append_buffer(x, buf, 3);
-}
-
-msgpack_pack_inline_func_fixint(_uint32)(msgpack_pack_user x, uint32_t d)
-{
-    unsigned char buf[5];
-    buf[0] = 0xce; _msgpack_store32(&buf[1], d);
-    msgpack_pack_append_buffer(x, buf, 5);
-}
-
-msgpack_pack_inline_func_fixint(_uint64)(msgpack_pack_user x, uint64_t d)
-{
-    unsigned char buf[9];
-    buf[0] = 0xcf; _msgpack_store64(&buf[1], d);
-    msgpack_pack_append_buffer(x, buf, 9);
-}
-
-msgpack_pack_inline_func_fixint(_int8)(msgpack_pack_user x, int8_t d)
-{
-    unsigned char buf[2] = {0xd0, TAKE8_8(d)};
-    msgpack_pack_append_buffer(x, buf, 2);
-}
-
-msgpack_pack_inline_func_fixint(_int16)(msgpack_pack_user x, int16_t d)
-{
-    unsigned char buf[3];
-    buf[0] = 0xd1; _msgpack_store16(&buf[1], d);
-    msgpack_pack_append_buffer(x, buf, 3);
-}
-
-msgpack_pack_inline_func_fixint(_int32)(msgpack_pack_user x, int32_t d)
-{
-    unsigned char buf[5];
-    buf[0] = 0xd2; _msgpack_store32(&buf[1], d);
-    msgpack_pack_append_buffer(x, buf, 5);
-}
-
-msgpack_pack_inline_func_fixint(_int64)(msgpack_pack_user x, int64_t d)
-{
-    unsigned char buf[9];
-    buf[0] = 0xd3; _msgpack_store64(&buf[1], d);
-    msgpack_pack_append_buffer(x, buf, 9);
-}
-
-#undef msgpack_pack_inline_func_fixint
-#endif
-
-
-msgpack_pack_inline_func(_uint8)(msgpack_pack_user x, uint8_t d)
-{
-    msgpack_pack_real_uint8(x, d);
-}
-
-msgpack_pack_inline_func(_uint16)(msgpack_pack_user x, uint16_t d)
-{
-    msgpack_pack_real_uint16(x, d);
-}
-
-msgpack_pack_inline_func(_uint32)(msgpack_pack_user x, uint32_t d)
-{
-    msgpack_pack_real_uint32(x, d);
-}
-
-msgpack_pack_inline_func(_uint64)(msgpack_pack_user x, uint64_t d)
-{
-    msgpack_pack_real_uint64(x, d);
-}
-
-msgpack_pack_inline_func(_int8)(msgpack_pack_user x, int8_t d)
-{
-    msgpack_pack_real_int8(x, d);
-}
-
-msgpack_pack_inline_func(_int16)(msgpack_pack_user x, int16_t d)
-{
-    msgpack_pack_real_int16(x, d);
-}
-
-msgpack_pack_inline_func(_int32)(msgpack_pack_user x, int32_t d)
-{
-    msgpack_pack_real_int32(x, d);
-}
-
-msgpack_pack_inline_func(_int64)(msgpack_pack_user x, int64_t d)
-{
-    msgpack_pack_real_int64(x, d);
-}
-
-msgpack_pack_inline_func(_char)(msgpack_pack_user x, char d)
-{
-#if defined(CHAR_MIN)
-#if CHAR_MIN < 0
-        msgpack_pack_real_int8(x, d);
-#else
-        msgpack_pack_real_uint8(x, d);
-#endif
-#else
-#error CHAR_MIN is not defined
-#endif
-}
-
-msgpack_pack_inline_func(_signed_char)(msgpack_pack_user x, signed char d)
-{
-    msgpack_pack_real_int8(x, d);
-}
-
-msgpack_pack_inline_func(_unsigned_char)(msgpack_pack_user x, unsigned char d)
-{
-    msgpack_pack_real_uint8(x, d);
-}
-
-#ifdef msgpack_pack_inline_func_cint
-
-msgpack_pack_inline_func_cint(_short)(msgpack_pack_user x, short d)
-{
-#if defined(SIZEOF_SHORT)
-#if SIZEOF_SHORT == 2
-    msgpack_pack_real_int16(x, d);
-#elif SIZEOF_SHORT == 4
-    msgpack_pack_real_int32(x, d);
-#else
-    msgpack_pack_real_int64(x, d);
-#endif
-
-#elif defined(SHRT_MAX)
-#if SHRT_MAX == 0x7fff
-    msgpack_pack_real_int16(x, d);
-#elif SHRT_MAX == 0x7fffffff
-    msgpack_pack_real_int32(x, d);
-#else
-    msgpack_pack_real_int64(x, d);
-#endif
-
-#else
-if(sizeof(short) == 2) {
-    msgpack_pack_real_int16(x, d);
-} else if(sizeof(short) == 4) {
-    msgpack_pack_real_int32(x, d);
-} else {
-    msgpack_pack_real_int64(x, d);
-}
-#endif
-}
-
-msgpack_pack_inline_func_cint(_int)(msgpack_pack_user x, int d)
-{
-#if defined(SIZEOF_INT)
-#if SIZEOF_INT == 2
-    msgpack_pack_real_int16(x, d);
-#elif SIZEOF_INT == 4
-    msgpack_pack_real_int32(x, d);
-#else
-    msgpack_pack_real_int64(x, d);
-#endif
-
-#elif defined(INT_MAX)
-#if INT_MAX == 0x7fff
-    msgpack_pack_real_int16(x, d);
-#elif INT_MAX == 0x7fffffff
-    msgpack_pack_real_int32(x, d);
-#else
-    msgpack_pack_real_int64(x, d);
-#endif
-
-#else
-if(sizeof(int) == 2) {
-    msgpack_pack_real_int16(x, d);
-} else if(sizeof(int) == 4) {
-    msgpack_pack_real_int32(x, d);
-} else {
-    msgpack_pack_real_int64(x, d);
-}
-#endif
-}
-
-msgpack_pack_inline_func_cint(_long)(msgpack_pack_user x, long d)
-{
-#if defined(SIZEOF_LONG)
-#if SIZEOF_LONG == 2
-    msgpack_pack_real_int16(x, d);
-#elif SIZEOF_LONG == 4
-    msgpack_pack_real_int32(x, d);
-#else
-    msgpack_pack_real_int64(x, d);
-#endif
-
-#elif defined(LONG_MAX)
-#if LONG_MAX == 0x7fffL
-    msgpack_pack_real_int16(x, d);
-#elif LONG_MAX == 0x7fffffffL
-    msgpack_pack_real_int32(x, d);
-#else
-    msgpack_pack_real_int64(x, d);
-#endif
-
-#else
-if(sizeof(long) == 2) {
-    msgpack_pack_real_int16(x, d);
-} else if(sizeof(long) == 4) {
-    msgpack_pack_real_int32(x, d);
-} else {
-    msgpack_pack_real_int64(x, d);
-}
-#endif
-}
-
-msgpack_pack_inline_func_cint(_long_long)(msgpack_pack_user x, long long d)
-{
-#if defined(SIZEOF_LONG_LONG)
-#if SIZEOF_LONG_LONG == 2
-    msgpack_pack_real_int16(x, d);
-#elif SIZEOF_LONG_LONG == 4
-    msgpack_pack_real_int32(x, d);
-#else
-    msgpack_pack_real_int64(x, d);
-#endif
-
-#elif defined(LLONG_MAX)
-#if LLONG_MAX == 0x7fffL
-    msgpack_pack_real_int16(x, d);
-#elif LLONG_MAX == 0x7fffffffL
-    msgpack_pack_real_int32(x, d);
-#else
-    msgpack_pack_real_int64(x, d);
-#endif
-
-#else
-if(sizeof(long long) == 2) {
-    msgpack_pack_real_int16(x, d);
-} else if(sizeof(long long) == 4) {
-    msgpack_pack_real_int32(x, d);
-} else {
-    msgpack_pack_real_int64(x, d);
-}
-#endif
-}
-
-msgpack_pack_inline_func_cint(_unsigned_short)(msgpack_pack_user x, unsigned short d)
-{
-#if defined(SIZEOF_SHORT)
-#if SIZEOF_SHORT == 2
-    msgpack_pack_real_uint16(x, d);
-#elif SIZEOF_SHORT == 4
-    msgpack_pack_real_uint32(x, d);
-#else
-    msgpack_pack_real_uint64(x, d);
-#endif
-
-#elif defined(USHRT_MAX)
-#if USHRT_MAX == 0xffffU
-    msgpack_pack_real_uint16(x, d);
-#elif USHRT_MAX == 0xffffffffU
-    msgpack_pack_real_uint32(x, d);
-#else
-    msgpack_pack_real_uint64(x, d);
-#endif
-
-#else
-if(sizeof(unsigned short) == 2) {
-    msgpack_pack_real_uint16(x, d);
-} else if(sizeof(unsigned short) == 4) {
-    msgpack_pack_real_uint32(x, d);
-} else {
-    msgpack_pack_real_uint64(x, d);
-}
-#endif
-}
-
-msgpack_pack_inline_func_cint(_unsigned_int)(msgpack_pack_user x, unsigned int d)
-{
-#if defined(SIZEOF_INT)
-#if SIZEOF_INT == 2
-    msgpack_pack_real_uint16(x, d);
-#elif SIZEOF_INT == 4
-    msgpack_pack_real_uint32(x, d);
-#else
-    msgpack_pack_real_uint64(x, d);
-#endif
-
-#elif defined(UINT_MAX)
-#if UINT_MAX == 0xffffU
-    msgpack_pack_real_uint16(x, d);
-#elif UINT_MAX == 0xffffffffU
-    msgpack_pack_real_uint32(x, d);
-#else
-    msgpack_pack_real_uint64(x, d);
-#endif
-
-#else
-if(sizeof(unsigned int) == 2) {
-    msgpack_pack_real_uint16(x, d);
-} else if(sizeof(unsigned int) == 4) {
-    msgpack_pack_real_uint32(x, d);
-} else {
-    msgpack_pack_real_uint64(x, d);
-}
-#endif
-}
-
-msgpack_pack_inline_func_cint(_unsigned_long)(msgpack_pack_user x, unsigned long d)
-{
-#if defined(SIZEOF_LONG)
-#if SIZEOF_LONG == 2
-    msgpack_pack_real_uint16(x, d);
-#elif SIZEOF_LONG == 4
-    msgpack_pack_real_uint32(x, d);
-#else
-    msgpack_pack_real_uint64(x, d);
-#endif
-
-#elif defined(ULONG_MAX)
-#if ULONG_MAX == 0xffffUL
-    msgpack_pack_real_uint16(x, d);
-#elif ULONG_MAX == 0xffffffffUL
-    msgpack_pack_real_uint32(x, d);
-#else
-    msgpack_pack_real_uint64(x, d);
-#endif
-
-#else
-if(sizeof(unsigned long) == 2) {
-    msgpack_pack_real_uint16(x, d);
-} else if(sizeof(unsigned long) == 4) {
-    msgpack_pack_real_uint32(x, d);
-} else {
-    msgpack_pack_real_uint64(x, d);
-}
-#endif
-}
-
-msgpack_pack_inline_func_cint(_unsigned_long_long)(msgpack_pack_user x, unsigned long long d)
-{
-#if defined(SIZEOF_LONG_LONG)
-#if SIZEOF_LONG_LONG == 2
-    msgpack_pack_real_uint16(x, d);
-#elif SIZEOF_LONG_LONG == 4
-    msgpack_pack_real_uint32(x, d);
-#else
-    msgpack_pack_real_uint64(x, d);
-#endif
-
-#elif defined(ULLONG_MAX)
-#if ULLONG_MAX == 0xffffUL
-    msgpack_pack_real_uint16(x, d);
-#elif ULLONG_MAX == 0xffffffffUL
-    msgpack_pack_real_uint32(x, d);
-#else
-    msgpack_pack_real_uint64(x, d);
-#endif
-
-#else
-if(sizeof(unsigned long long) == 2) {
-    msgpack_pack_real_uint16(x, d);
-} else if(sizeof(unsigned long long) == 4) {
-    msgpack_pack_real_uint32(x, d);
-} else {
-    msgpack_pack_real_uint64(x, d);
-}
-#endif
-}
-
-#undef msgpack_pack_inline_func_cint
-#endif
-
-
-
-/*
- * Float
- */
-
-msgpack_pack_inline_func(_float)(msgpack_pack_user x, float d)
-{
-    unsigned char buf[5];
-    union { float f; uint32_t i; } mem;
-    mem.f = d;
-    buf[0] = 0xca; _msgpack_store32(&buf[1], mem.i);
-    msgpack_pack_append_buffer(x, buf, 5);
-}
-
-msgpack_pack_inline_func(_double)(msgpack_pack_user x, double d)
-{
-    unsigned char buf[9];
-    union { double f; uint64_t i; } mem;
-    mem.f = d;
-    buf[0] = 0xcb;
-#if defined(TARGET_OS_IPHONE)
-    // ok
-#elif defined(__arm__) && !(__ARM_EABI__) // arm-oabi
-    // https://github.com/msgpack/msgpack-perl/pull/1
-    mem.i = (mem.i & 0xFFFFFFFFUL) << 32UL | (mem.i >> 32UL);
-#endif
-    _msgpack_store64(&buf[1], mem.i);
-    msgpack_pack_append_buffer(x, buf, 9);
-}
-
-
-/*
- * Nil
- */
-
-msgpack_pack_inline_func(_nil)(msgpack_pack_user x)
-{
-    static const unsigned char d = 0xc0;
-    msgpack_pack_append_buffer(x, &d, 1);
-}
-
-
-/*
- * Boolean
- */
-
-msgpack_pack_inline_func(_true)(msgpack_pack_user x)
-{
-    static const unsigned char d = 0xc3;
-    msgpack_pack_append_buffer(x, &d, 1);
-}
-
-msgpack_pack_inline_func(_false)(msgpack_pack_user x)
-{
-    static const unsigned char d = 0xc2;
-    msgpack_pack_append_buffer(x, &d, 1);
-}
-
-
-/*
- * Array
- */
-
-msgpack_pack_inline_func(_array)(msgpack_pack_user x, size_t n)
-{
-    if(n < 16) {
-        unsigned char d = 0x90 | (uint8_t)n;
-        msgpack_pack_append_buffer(x, &d, 1);
-    } else if(n < 65536) {
-        unsigned char buf[3];
-        buf[0] = 0xdc; _msgpack_store16(&buf[1], (uint16_t)n);
-        msgpack_pack_append_buffer(x, buf, 3);
-    } else {
-        unsigned char buf[5];
-        buf[0] = 0xdd; _msgpack_store32(&buf[1], (uint32_t)n);
-        msgpack_pack_append_buffer(x, buf, 5);
-    }
-}
-
-
-/*
- * Map
- */
-
-msgpack_pack_inline_func(_map)(msgpack_pack_user x, size_t n)
-{
-    if(n < 16) {
-        unsigned char d = 0x80 | (uint8_t)n;
-        msgpack_pack_append_buffer(x, &TAKE8_8(d), 1);
-    } else if(n < 65536) {
-        unsigned char buf[3];
-        buf[0] = 0xde; _msgpack_store16(&buf[1], (uint16_t)n);
-        msgpack_pack_append_buffer(x, buf, 3);
-    } else {
-        unsigned char buf[5];
-        buf[0] = 0xdf; _msgpack_store32(&buf[1], (uint32_t)n);
-        msgpack_pack_append_buffer(x, buf, 5);
-    }
-}
-
-
-/*
- * Str
- */
-
-msgpack_pack_inline_func(_str)(msgpack_pack_user x, size_t l)
-{
-    if(l < 32) {
-        unsigned char d = 0xa0 | (uint8_t)l;
-        msgpack_pack_append_buffer(x, &TAKE8_8(d), 1);
-    } else if(l < 256) {
-        unsigned char buf[2];
-        buf[0] = 0xd9; buf[1] = (uint8_t)l;
-        msgpack_pack_append_buffer(x, buf, 2);
-    } else if(l < 65536) {
-        unsigned char buf[3];
-        buf[0] = 0xda; _msgpack_store16(&buf[1], (uint16_t)l);
-        msgpack_pack_append_buffer(x, buf, 3);
-    } else {
-        unsigned char buf[5];
-        buf[0] = 0xdb; _msgpack_store32(&buf[1], (uint32_t)l);
-        msgpack_pack_append_buffer(x, buf, 5);
-    }
-}
-
-msgpack_pack_inline_func(_str_body)(msgpack_pack_user x, const void* b, size_t l)
-{
-    msgpack_pack_append_buffer(x, (const unsigned char*)b, l);
-}
-
-/*
- * Raw (V4)
- */
-
-msgpack_pack_inline_func(_v4raw)(msgpack_pack_user x, size_t l)
-{
-    if(l < 32) {
-        unsigned char d = 0xa0 | (uint8_t)l;
-        msgpack_pack_append_buffer(x, &TAKE8_8(d), 1);
-    } else if(l < 65536) {
-        unsigned char buf[3];
-        buf[0] = 0xda; _msgpack_store16(&buf[1], (uint16_t)l);
-        msgpack_pack_append_buffer(x, buf, 3);
-    } else {
-        unsigned char buf[5];
-        buf[0] = 0xdb; _msgpack_store32(&buf[1], (uint32_t)l);
-        msgpack_pack_append_buffer(x, buf, 5);
-    }
-}
-
-msgpack_pack_inline_func(_v4raw_body)(msgpack_pack_user x, const void* b, size_t l)
-{
-    msgpack_pack_append_buffer(x, (const unsigned char*)b, l);
-}
-
-/*
- * Bin
- */
-
-msgpack_pack_inline_func(_bin)(msgpack_pack_user x, size_t l)
-{
-    if(l < 256) {
-        unsigned char buf[2];
-        buf[0] = 0xc4; buf[1] = (uint8_t)l;
-        msgpack_pack_append_buffer(x, buf, 2);
-    } else if(l < 65536) {
-        unsigned char buf[3];
-        buf[0] = 0xc5; _msgpack_store16(&buf[1], (uint16_t)l);
-        msgpack_pack_append_buffer(x, buf, 3);
-    } else {
-        unsigned char buf[5];
-        buf[0] = 0xc6; _msgpack_store32(&buf[1], (uint32_t)l);
-        msgpack_pack_append_buffer(x, buf, 5);
-    }
-}
-
-msgpack_pack_inline_func(_bin_body)(msgpack_pack_user x, const void* b, size_t l)
-{
-    msgpack_pack_append_buffer(x, (const unsigned char*)b, l);
-}
-
-/*
- * Ext
- */
-
-msgpack_pack_inline_func(_ext)(msgpack_pack_user x, size_t l, int8_t type)
-{
-    switch(l) {
-    case 1: {
-        unsigned char buf[2];
-        buf[0] = 0xd4;
-        buf[1] = (unsigned char)type;
-        msgpack_pack_append_buffer(x, buf, 2);
-    } break;
-    case 2: {
-        unsigned char buf[2];
-        buf[0] = 0xd5;
-        buf[1] = (unsigned char)type;
-        msgpack_pack_append_buffer(x, buf, 2);
-    } break;
-    case 4: {
-        unsigned char buf[2];
-        buf[0] = 0xd6;
-        buf[1] = (unsigned char)type;
-        msgpack_pack_append_buffer(x, buf, 2);
-    } break;
-    case 8: {
-        unsigned char buf[2];
-        buf[0] = 0xd7;
-        buf[1] = (unsigned char)type;
-        msgpack_pack_append_buffer(x, buf, 2);
-    } break;
-    case 16: {
-        unsigned char buf[2];
-        buf[0] = 0xd8;
-        buf[1] = (unsigned char)type;
-        msgpack_pack_append_buffer(x, buf, 2);
-    } break;
-    default:
-        if(l < 256) {
-            unsigned char buf[3];
-            buf[0] = 0xc7;
-            buf[1] = (unsigned char)l;
-            buf[2] = (unsigned char)type;
-            msgpack_pack_append_buffer(x, buf, 3);
-        } else if(l < 65536) {
-            unsigned char buf[4];
-            buf[0] = 0xc8;
-            _msgpack_store16(&buf[1], l);
-            buf[3] = (unsigned char)type;
-            msgpack_pack_append_buffer(x, buf, 4);
-        } else {
-            unsigned char buf[6];
-            buf[0] = 0xc9;
-            _msgpack_store32(&buf[1], l);
-            buf[5] = (unsigned char)type;
-            msgpack_pack_append_buffer(x, buf, 6);
-        }
-        break;
-    }
-}
-
-msgpack_pack_inline_func(_ext_body)(msgpack_pack_user x, const void* b, size_t l)
-{
-    msgpack_pack_append_buffer(x, (const unsigned char*)b, l);
-}
-
-msgpack_pack_inline_func(_timestamp)(msgpack_pack_user x, const msgpack_timestamp* d)
-{
-    if ((((int64_t)d->tv_sec) >> 34) == 0) {
-        uint64_t data64 = ((uint64_t) d->tv_nsec << 34) | (uint64_t)d->tv_sec;
-        if ((data64 & 0xffffffff00000000L) == 0)   {
-            // timestamp 32
-            char buf[4];
-            uint32_t data32 = (uint32_t)data64;
-            msgpack_pack_ext(x, 4, -1);
-            _msgpack_store32(buf, data32);
-            msgpack_pack_append_buffer(x, buf, 4);
-        } else {
-            // timestamp 64
-            char buf[8];
-            msgpack_pack_ext(x, 8, -1);
-            _msgpack_store64(buf, data64);
-            msgpack_pack_append_buffer(x, buf, 8);
-        }
-    } else  {
-        // timestamp 96
-        char buf[12];
-        _msgpack_store32(&buf[0], d->tv_nsec);
-        _msgpack_store64(&buf[4], d->tv_sec);
-        msgpack_pack_ext(x, 12, -1);
-        msgpack_pack_append_buffer(x, buf, 12);
-    }
-}
-
-#undef msgpack_pack_inline_func
-#undef msgpack_pack_user
-#undef msgpack_pack_append_buffer
-
-#undef TAKE8_8
-#undef TAKE8_16
-#undef TAKE8_32
-#undef TAKE8_64
-
-#undef msgpack_pack_real_uint8
-#undef msgpack_pack_real_uint16
-#undef msgpack_pack_real_uint32
-#undef msgpack_pack_real_uint64
-#undef msgpack_pack_real_int8
-#undef msgpack_pack_real_int16
-#undef msgpack_pack_real_int32
-#undef msgpack_pack_real_int64
-
-#if defined(_MSC_VER)
-#   pragma warning(pop)
-#endif
+/*
+ * MessagePack packing routine template
+ *
+ * Copyright (C) 2008-2010 FURUHASHI Sadayuki
+ *
+ *    Distributed under the Boost Software License, Version 1.0.
+ *    (See accompanying file LICENSE_1_0.txt or copy at
+ *    http://www.boost.org/LICENSE_1_0.txt)
+ */
+
+#ifndef MSGPACK_ENDIAN_BIG_BYTE
+#define MSGPACK_ENDIAN_BIG_BYTE 0
+#endif
+#ifndef MSGPACK_ENDIAN_LITTLE_BYTE
+#define MSGPACK_ENDIAN_LITTLE_BYTE 1
+#endif
+
+#if MSGPACK_ENDIAN_LITTLE_BYTE
+#define TAKE8_8(d)  ((uint8_t*)&d)[0]
+#define TAKE8_16(d) ((uint8_t*)&d)[0]
+#define TAKE8_32(d) ((uint8_t*)&d)[0]
+#define TAKE8_64(d) ((uint8_t*)&d)[0]
+#elif MSGPACK_ENDIAN_BIG_BYTE
+#define TAKE8_8(d)  ((uint8_t*)&d)[0]
+#define TAKE8_16(d) ((uint8_t*)&d)[1]
+#define TAKE8_32(d) ((uint8_t*)&d)[3]
+#define TAKE8_64(d) ((uint8_t*)&d)[7]
+#else
+#error msgpack-c supports only big endian and little endian
+#endif
+
+#ifndef msgpack_pack_inline_func
+#error msgpack_pack_inline_func template is not defined
+#endif
+
+#ifndef msgpack_pack_user
+#error msgpack_pack_user type is not defined
+#endif
+
+#ifndef msgpack_pack_append_buffer
+#error msgpack_pack_append_buffer callback is not defined
+#endif
+
+#if defined(_MSC_VER)
+#   pragma warning(push)
+#   pragma warning(disable : 4204)   /* nonstandard extension used: non-constant aggregate initializer */
+#endif
+
+/*
+ * Integer
+ */
+
+#define msgpack_pack_real_uint8(x, d) \
+do { \
+    if(d < (1<<7)) { \
+        /* fixnum */ \
+        msgpack_pack_append_buffer(x, &TAKE8_8(d), 1); \
+    } else { \
+        /* unsigned 8 */ \
+        unsigned char buf[2] = {0xcc, TAKE8_8(d)}; \
+        msgpack_pack_append_buffer(x, buf, 2); \
+    } \
+} while(0)
+
+#define msgpack_pack_real_uint16(x, d) \
+do { \
+    if(d < (1<<7)) { \
+        /* fixnum */ \
+        msgpack_pack_append_buffer(x, &TAKE8_16(d), 1); \
+    } else if(d < (1<<8)) { \
+        /* unsigned 8 */ \
+        unsigned char buf[2] = {0xcc, TAKE8_16(d)}; \
+        msgpack_pack_append_buffer(x, buf, 2); \
+    } else { \
+        /* unsigned 16 */ \
+        unsigned char buf[3]; \
+        buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
+        msgpack_pack_append_buffer(x, buf, 3); \
+    } \
+} while(0)
+
+#define msgpack_pack_real_uint32(x, d) \
+do { \
+    if(d < (1<<8)) { \
+        if(d < (1<<7)) { \
+            /* fixnum */ \
+            msgpack_pack_append_buffer(x, &TAKE8_32(d), 1); \
+        } else { \
+            /* unsigned 8 */ \
+            unsigned char buf[2] = {0xcc, TAKE8_32(d)}; \
+            msgpack_pack_append_buffer(x, buf, 2); \
+        } \
+    } else { \
+        if(d < (1<<16)) { \
+            /* unsigned 16 */ \
+            unsigned char buf[3]; \
+            buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
+            msgpack_pack_append_buffer(x, buf, 3); \
+        } else { \
+            /* unsigned 32 */ \
+            unsigned char buf[5]; \
+            buf[0] = 0xce; _msgpack_store32(&buf[1], (uint32_t)d); \
+            msgpack_pack_append_buffer(x, buf, 5); \
+        } \
+    } \
+} while(0)
+
+#define msgpack_pack_real_uint64(x, d) \
+do { \
+    if(d < (1ULL<<8)) { \
+        if(d < (1ULL<<7)) { \
+            /* fixnum */ \
+            msgpack_pack_append_buffer(x, &TAKE8_64(d), 1); \
+        } else { \
+            /* unsigned 8 */ \
+            unsigned char buf[2] = {0xcc, TAKE8_64(d)}; \
+            msgpack_pack_append_buffer(x, buf, 2); \
+        } \
+    } else { \
+        if(d < (1ULL<<16)) { \
+            /* unsigned 16 */ \
+            unsigned char buf[3]; \
+            buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
+            msgpack_pack_append_buffer(x, buf, 3); \
+        } else if(d < (1ULL<<32)) { \
+            /* unsigned 32 */ \
+            unsigned char buf[5]; \
+            buf[0] = 0xce; _msgpack_store32(&buf[1], (uint32_t)d); \
+            msgpack_pack_append_buffer(x, buf, 5); \
+        } else { \
+            /* unsigned 64 */ \
+            unsigned char buf[9]; \
+            buf[0] = 0xcf; _msgpack_store64(&buf[1], d); \
+            msgpack_pack_append_buffer(x, buf, 9); \
+        } \
+    } \
+} while(0)
+
+#define msgpack_pack_real_int8(x, d) \
+do { \
+    if(d < -(1<<5)) { \
+        /* signed 8 */ \
+        unsigned char buf[2] = {0xd0, TAKE8_8(d)}; \
+        msgpack_pack_append_buffer(x, buf, 2); \
+    } else { \
+        /* fixnum */ \
+        msgpack_pack_append_buffer(x, &TAKE8_8(d), 1); \
+    } \
+} while(0)
+
+#define msgpack_pack_real_int16(x, d) \
+do { \
+    if(d < -(1<<5)) { \
+        if(d < -(1<<7)) { \
+            /* signed 16 */ \
+            unsigned char buf[3]; \
+            buf[0] = 0xd1; _msgpack_store16(&buf[1], (int16_t)d); \
+            msgpack_pack_append_buffer(x, buf, 3); \
+        } else { \
+            /* signed 8 */ \
+            unsigned char buf[2] = {0xd0, TAKE8_16(d)}; \
+            msgpack_pack_append_buffer(x, buf, 2); \
+        } \
+    } else if(d < (1<<7)) { \
+        /* fixnum */ \
+        msgpack_pack_append_buffer(x, &TAKE8_16(d), 1); \
+    } else { \
+        if(d < (1<<8)) { \
+            /* unsigned 8 */ \
+            unsigned char buf[2] = {0xcc, TAKE8_16(d)}; \
+            msgpack_pack_append_buffer(x, buf, 2); \
+        } else { \
+            /* unsigned 16 */ \
+            unsigned char buf[3]; \
+            buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
+            msgpack_pack_append_buffer(x, buf, 3); \
+        } \
+    } \
+} while(0)
+
+#define msgpack_pack_real_int32(x, d) \
+do { \
+    if(d < -(1<<5)) { \
+        if(d < -(1<<15)) { \
+            /* signed 32 */ \
+            unsigned char buf[5]; \
+            buf[0] = 0xd2; _msgpack_store32(&buf[1], (int32_t)d); \
+            msgpack_pack_append_buffer(x, buf, 5); \
+        } else if(d < -(1<<7)) { \
+            /* signed 16 */ \
+            unsigned char buf[3]; \
+            buf[0] = 0xd1; _msgpack_store16(&buf[1], (int16_t)d); \
+            msgpack_pack_append_buffer(x, buf, 3); \
+        } else { \
+            /* signed 8 */ \
+            unsigned char buf[2] = {0xd0, TAKE8_32(d)}; \
+            msgpack_pack_append_buffer(x, buf, 2); \
+        } \
+    } else if(d < (1<<7)) { \
+        /* fixnum */ \
+        msgpack_pack_append_buffer(x, &TAKE8_32(d), 1); \
+    } else { \
+        if(d < (1<<8)) { \
+            /* unsigned 8 */ \
+            unsigned char buf[2] = {0xcc, TAKE8_32(d)}; \
+            msgpack_pack_append_buffer(x, buf, 2); \
+        } else if(d < (1<<16)) { \
+            /* unsigned 16 */ \
+            unsigned char buf[3]; \
+            buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
+            msgpack_pack_append_buffer(x, buf, 3); \
+        } else { \
+            /* unsigned 32 */ \
+            unsigned char buf[5]; \
+            buf[0] = 0xce; _msgpack_store32(&buf[1], (uint32_t)d); \
+            msgpack_pack_append_buffer(x, buf, 5); \
+        } \
+    } \
+} while(0)
+
+#define msgpack_pack_real_int64(x, d) \
+do { \
+    if(d < -(1LL<<5)) { \
+        if(d < -(1LL<<15)) { \
+            if(d < -(1LL<<31)) { \
+                /* signed 64 */ \
+                unsigned char buf[9]; \
+                buf[0] = 0xd3; _msgpack_store64(&buf[1], d); \
+                msgpack_pack_append_buffer(x, buf, 9); \
+            } else { \
+                /* signed 32 */ \
+                unsigned char buf[5]; \
+                buf[0] = 0xd2; _msgpack_store32(&buf[1], (int32_t)d); \
+                msgpack_pack_append_buffer(x, buf, 5); \
+            } \
+        } else { \
+            if(d < -(1<<7)) { \
+                /* signed 16 */ \
+                unsigned char buf[3]; \
+                buf[0] = 0xd1; _msgpack_store16(&buf[1], (int16_t)d); \
+                msgpack_pack_append_buffer(x, buf, 3); \
+            } else { \
+                /* signed 8 */ \
+                unsigned char buf[2] = {0xd0, TAKE8_64(d)}; \
+                msgpack_pack_append_buffer(x, buf, 2); \
+            } \
+        } \
+    } else if(d < (1<<7)) { \
+        /* fixnum */ \
+        msgpack_pack_append_buffer(x, &TAKE8_64(d), 1); \
+    } else { \
+        if(d < (1LL<<16)) { \
+            if(d < (1<<8)) { \
+                /* unsigned 8 */ \
+                unsigned char buf[2] = {0xcc, TAKE8_64(d)}; \
+                msgpack_pack_append_buffer(x, buf, 2); \
+            } else { \
+                /* unsigned 16 */ \
+                unsigned char buf[3]; \
+                buf[0] = 0xcd; _msgpack_store16(&buf[1], (uint16_t)d); \
+                msgpack_pack_append_buffer(x, buf, 3); \
+            } \
+        } else { \
+            if(d < (1LL<<32)) { \
+                /* unsigned 32 */ \
+                unsigned char buf[5]; \
+                buf[0] = 0xce; _msgpack_store32(&buf[1], (uint32_t)d); \
+                msgpack_pack_append_buffer(x, buf, 5); \
+            } else { \
+                /* unsigned 64 */ \
+                unsigned char buf[9]; \
+                buf[0] = 0xcf; _msgpack_store64(&buf[1], d); \
+                msgpack_pack_append_buffer(x, buf, 9); \
+            } \
+        } \
+    } \
+} while(0)
+
+
+#ifdef msgpack_pack_inline_func_fixint
+
+msgpack_pack_inline_func_fixint(_uint8)(msgpack_pack_user x, uint8_t d)
+{
+    unsigned char buf[2] = {0xcc, TAKE8_8(d)};
+    msgpack_pack_append_buffer(x, buf, 2);
+}
+
+msgpack_pack_inline_func_fixint(_uint16)(msgpack_pack_user x, uint16_t d)
+{
+    unsigned char buf[3];
+    buf[0] = 0xcd; _msgpack_store16(&buf[1], d);
+    msgpack_pack_append_buffer(x, buf, 3);
+}
+
+msgpack_pack_inline_func_fixint(_uint32)(msgpack_pack_user x, uint32_t d)
+{
+    unsigned char buf[5];
+    buf[0] = 0xce; _msgpack_store32(&buf[1], d);
+    msgpack_pack_append_buffer(x, buf, 5);
+}
+
+msgpack_pack_inline_func_fixint(_uint64)(msgpack_pack_user x, uint64_t d)
+{
+    unsigned char buf[9];
+    buf[0] = 0xcf; _msgpack_store64(&buf[1], d);
+    msgpack_pack_append_buffer(x, buf, 9);
+}
+
+msgpack_pack_inline_func_fixint(_int8)(msgpack_pack_user x, int8_t d)
+{
+    unsigned char buf[2] = {0xd0, TAKE8_8(d)};
+    msgpack_pack_append_buffer(x, buf, 2);
+}
+
+msgpack_pack_inline_func_fixint(_int16)(msgpack_pack_user x, int16_t d)
+{
+    unsigned char buf[3];
+    buf[0] = 0xd1; _msgpack_store16(&buf[1], d);
+    msgpack_pack_append_buffer(x, buf, 3);
+}
+
+msgpack_pack_inline_func_fixint(_int32)(msgpack_pack_user x, int32_t d)
+{
+    unsigned char buf[5];
+    buf[0] = 0xd2; _msgpack_store32(&buf[1], d);
+    msgpack_pack_append_buffer(x, buf, 5);
+}
+
+msgpack_pack_inline_func_fixint(_int64)(msgpack_pack_user x, int64_t d)
+{
+    unsigned char buf[9];
+    buf[0] = 0xd3; _msgpack_store64(&buf[1], d);
+    msgpack_pack_append_buffer(x, buf, 9);
+}
+
+#undef msgpack_pack_inline_func_fixint
+#endif
+
+
+msgpack_pack_inline_func(_uint8)(msgpack_pack_user x, uint8_t d)
+{
+    msgpack_pack_real_uint8(x, d);
+}
+
+msgpack_pack_inline_func(_uint16)(msgpack_pack_user x, uint16_t d)
+{
+    msgpack_pack_real_uint16(x, d);
+}
+
+msgpack_pack_inline_func(_uint32)(msgpack_pack_user x, uint32_t d)
+{
+    msgpack_pack_real_uint32(x, d);
+}
+
+msgpack_pack_inline_func(_uint64)(msgpack_pack_user x, uint64_t d)
+{
+    msgpack_pack_real_uint64(x, d);
+}
+
+msgpack_pack_inline_func(_int8)(msgpack_pack_user x, int8_t d)
+{
+    msgpack_pack_real_int8(x, d);
+}
+
+msgpack_pack_inline_func(_int16)(msgpack_pack_user x, int16_t d)
+{
+    msgpack_pack_real_int16(x, d);
+}
+
+msgpack_pack_inline_func(_int32)(msgpack_pack_user x, int32_t d)
+{
+    msgpack_pack_real_int32(x, d);
+}
+
+msgpack_pack_inline_func(_int64)(msgpack_pack_user x, int64_t d)
+{
+    msgpack_pack_real_int64(x, d);
+}
+
+msgpack_pack_inline_func(_char)(msgpack_pack_user x, char d)
+{
+#if defined(CHAR_MIN)
+#if CHAR_MIN < 0
+        msgpack_pack_real_int8(x, d);
+#else
+        msgpack_pack_real_uint8(x, d);
+#endif
+#else
+#error CHAR_MIN is not defined
+#endif
+}
+
+msgpack_pack_inline_func(_signed_char)(msgpack_pack_user x, signed char d)
+{
+    msgpack_pack_real_int8(x, d);
+}
+
+msgpack_pack_inline_func(_unsigned_char)(msgpack_pack_user x, unsigned char d)
+{
+    msgpack_pack_real_uint8(x, d);
+}
+
+#ifdef msgpack_pack_inline_func_cint
+
+msgpack_pack_inline_func_cint(_short)(msgpack_pack_user x, short d)
+{
+#if defined(SIZEOF_SHORT)
+#if SIZEOF_SHORT == 2
+    msgpack_pack_real_int16(x, d);
+#elif SIZEOF_SHORT == 4
+    msgpack_pack_real_int32(x, d);
+#else
+    msgpack_pack_real_int64(x, d);
+#endif
+
+#elif defined(SHRT_MAX)
+#if SHRT_MAX == 0x7fff
+    msgpack_pack_real_int16(x, d);
+#elif SHRT_MAX == 0x7fffffff
+    msgpack_pack_real_int32(x, d);
+#else
+    msgpack_pack_real_int64(x, d);
+#endif
+
+#else
+if(sizeof(short) == 2) {
+    msgpack_pack_real_int16(x, d);
+} else if(sizeof(short) == 4) {
+    msgpack_pack_real_int32(x, d);
+} else {
+    msgpack_pack_real_int64(x, d);
+}
+#endif
+}
+
+msgpack_pack_inline_func_cint(_int)(msgpack_pack_user x, int d)
+{
+#if defined(SIZEOF_INT)
+#if SIZEOF_INT == 2
+    msgpack_pack_real_int16(x, d);
+#elif SIZEOF_INT == 4
+    msgpack_pack_real_int32(x, d);
+#else
+    msgpack_pack_real_int64(x, d);
+#endif
+
+#elif defined(INT_MAX)
+#if INT_MAX == 0x7fff
+    msgpack_pack_real_int16(x, d);
+#elif INT_MAX == 0x7fffffff
+    msgpack_pack_real_int32(x, d);
+#else
+    msgpack_pack_real_int64(x, d);
+#endif
+
+#else
+if(sizeof(int) == 2) {
+    msgpack_pack_real_int16(x, d);
+} else if(sizeof(int) == 4) {
+    msgpack_pack_real_int32(x, d);
+} else {
+    msgpack_pack_real_int64(x, d);
+}
+#endif
+}
+
+msgpack_pack_inline_func_cint(_long)(msgpack_pack_user x, long d)
+{
+#if defined(SIZEOF_LONG)
+#if SIZEOF_LONG == 2
+    msgpack_pack_real_int16(x, d);
+#elif SIZEOF_LONG == 4
+    msgpack_pack_real_int32(x, d);
+#else
+    msgpack_pack_real_int64(x, d);
+#endif
+
+#elif defined(LONG_MAX)
+#if LONG_MAX == 0x7fffL
+    msgpack_pack_real_int16(x, d);
+#elif LONG_MAX == 0x7fffffffL
+    msgpack_pack_real_int32(x, d);
+#else
+    msgpack_pack_real_int64(x, d);
+#endif
+
+#else
+if(sizeof(long) == 2) {
+    msgpack_pack_real_int16(x, d);
+} else if(sizeof(long) == 4) {
+    msgpack_pack_real_int32(x, d);
+} else {
+    msgpack_pack_real_int64(x, d);
+}
+#endif
+}
+
+msgpack_pack_inline_func_cint(_long_long)(msgpack_pack_user x, long long d)
+{
+#if defined(SIZEOF_LONG_LONG)
+#if SIZEOF_LONG_LONG == 2
+    msgpack_pack_real_int16(x, d);
+#elif SIZEOF_LONG_LONG == 4
+    msgpack_pack_real_int32(x, d);
+#else
+    msgpack_pack_real_int64(x, d);
+#endif
+
+#elif defined(LLONG_MAX)
+#if LLONG_MAX == 0x7fffL
+    msgpack_pack_real_int16(x, d);
+#elif LLONG_MAX == 0x7fffffffL
+    msgpack_pack_real_int32(x, d);
+#else
+    msgpack_pack_real_int64(x, d);
+#endif
+
+#else
+if(sizeof(long long) == 2) {
+    msgpack_pack_real_int16(x, d);
+} else if(sizeof(long long) == 4) {
+    msgpack_pack_real_int32(x, d);
+} else {
+    msgpack_pack_real_int64(x, d);
+}
+#endif
+}
+
+msgpack_pack_inline_func_cint(_unsigned_short)(msgpack_pack_user x, unsigned short d)
+{
+#if defined(SIZEOF_SHORT)
+#if SIZEOF_SHORT == 2
+    msgpack_pack_real_uint16(x, d);
+#elif SIZEOF_SHORT == 4
+    msgpack_pack_real_uint32(x, d);
+#else
+    msgpack_pack_real_uint64(x, d);
+#endif
+
+#elif defined(USHRT_MAX)
+#if USHRT_MAX == 0xffffU
+    msgpack_pack_real_uint16(x, d);
+#elif USHRT_MAX == 0xffffffffU
+    msgpack_pack_real_uint32(x, d);
+#else
+    msgpack_pack_real_uint64(x, d);
+#endif
+
+#else
+if(sizeof(unsigned short) == 2) {
+    msgpack_pack_real_uint16(x, d);
+} else if(sizeof(unsigned short) == 4) {
+    msgpack_pack_real_uint32(x, d);
+} else {
+    msgpack_pack_real_uint64(x, d);
+}
+#endif
+}
+
+msgpack_pack_inline_func_cint(_unsigned_int)(msgpack_pack_user x, unsigned int d)
+{
+#if defined(SIZEOF_INT)
+#if SIZEOF_INT == 2
+    msgpack_pack_real_uint16(x, d);
+#elif SIZEOF_INT == 4
+    msgpack_pack_real_uint32(x, d);
+#else
+    msgpack_pack_real_uint64(x, d);
+#endif
+
+#elif defined(UINT_MAX)
+#if UINT_MAX == 0xffffU
+    msgpack_pack_real_uint16(x, d);
+#elif UINT_MAX == 0xffffffffU
+    msgpack_pack_real_uint32(x, d);
+#else
+    msgpack_pack_real_uint64(x, d);
+#endif
+
+#else
+if(sizeof(unsigned int) == 2) {
+    msgpack_pack_real_uint16(x, d);
+} else if(sizeof(unsigned int) == 4) {
+    msgpack_pack_real_uint32(x, d);
+} else {
+    msgpack_pack_real_uint64(x, d);
+}
+#endif
+}
+
+msgpack_pack_inline_func_cint(_unsigned_long)(msgpack_pack_user x, unsigned long d)
+{
+#if defined(SIZEOF_LONG)
+#if SIZEOF_LONG == 2
+    msgpack_pack_real_uint16(x, d);
+#elif SIZEOF_LONG == 4
+    msgpack_pack_real_uint32(x, d);
+#else
+    msgpack_pack_real_uint64(x, d);
+#endif
+
+#elif defined(ULONG_MAX)
+#if ULONG_MAX == 0xffffUL
+    msgpack_pack_real_uint16(x, d);
+#elif ULONG_MAX == 0xffffffffUL
+    msgpack_pack_real_uint32(x, d);
+#else
+    msgpack_pack_real_uint64(x, d);
+#endif
+
+#else
+if(sizeof(unsigned long) == 2) {
+    msgpack_pack_real_uint16(x, d);
+} else if(sizeof(unsigned long) == 4) {
+    msgpack_pack_real_uint32(x, d);
+} else {
+    msgpack_pack_real_uint64(x, d);
+}
+#endif
+}
+
+msgpack_pack_inline_func_cint(_unsigned_long_long)(msgpack_pack_user x, unsigned long long d)
+{
+#if defined(SIZEOF_LONG_LONG)
+#if SIZEOF_LONG_LONG == 2
+    msgpack_pack_real_uint16(x, d);
+#elif SIZEOF_LONG_LONG == 4
+    msgpack_pack_real_uint32(x, d);
+#else
+    msgpack_pack_real_uint64(x, d);
+#endif
+
+#elif defined(ULLONG_MAX)
+#if ULLONG_MAX == 0xffffUL
+    msgpack_pack_real_uint16(x, d);
+#elif ULLONG_MAX == 0xffffffffUL
+    msgpack_pack_real_uint32(x, d);
+#else
+    msgpack_pack_real_uint64(x, d);
+#endif
+
+#else
+if(sizeof(unsigned long long) == 2) {
+    msgpack_pack_real_uint16(x, d);
+} else if(sizeof(unsigned long long) == 4) {
+    msgpack_pack_real_uint32(x, d);
+} else {
+    msgpack_pack_real_uint64(x, d);
+}
+#endif
+}
+
+#undef msgpack_pack_inline_func_cint
+#endif
+
+
+
+/*
+ * Float
+ */
+
+msgpack_pack_inline_func(_float)(msgpack_pack_user x, float d)
+{
+    unsigned char buf[5];
+    union { float f; uint32_t i; } mem;
+    mem.f = d;
+    buf[0] = 0xca; _msgpack_store32(&buf[1], mem.i);
+    msgpack_pack_append_buffer(x, buf, 5);
+}
+
+msgpack_pack_inline_func(_double)(msgpack_pack_user x, double d)
+{
+    unsigned char buf[9];
+    union { double f; uint64_t i; } mem;
+    mem.f = d;
+    buf[0] = 0xcb;
+#if defined(TARGET_OS_IPHONE)
+    // ok
+#elif defined(__arm__) && !(__ARM_EABI__) // arm-oabi
+    // https://github.com/msgpack/msgpack-perl/pull/1
+    mem.i = (mem.i & 0xFFFFFFFFUL) << 32UL | (mem.i >> 32UL);
+#endif
+    _msgpack_store64(&buf[1], mem.i);
+    msgpack_pack_append_buffer(x, buf, 9);
+}
+
+
+/*
+ * Nil
+ */
+
+msgpack_pack_inline_func(_nil)(msgpack_pack_user x)
+{
+    static const unsigned char d = 0xc0;
+    msgpack_pack_append_buffer(x, &d, 1);
+}
+
+
+/*
+ * Boolean
+ */
+
+msgpack_pack_inline_func(_true)(msgpack_pack_user x)
+{
+    static const unsigned char d = 0xc3;
+    msgpack_pack_append_buffer(x, &d, 1);
+}
+
+msgpack_pack_inline_func(_false)(msgpack_pack_user x)
+{
+    static const unsigned char d = 0xc2;
+    msgpack_pack_append_buffer(x, &d, 1);
+}
+
+
+/*
+ * Array
+ */
+
+msgpack_pack_inline_func(_array)(msgpack_pack_user x, size_t n)
+{
+    if(n < 16) {
+        unsigned char d = 0x90 | (uint8_t)n;
+        msgpack_pack_append_buffer(x, &d, 1);
+    } else if(n < 65536) {
+        unsigned char buf[3];
+        buf[0] = 0xdc; _msgpack_store16(&buf[1], (uint16_t)n);
+        msgpack_pack_append_buffer(x, buf, 3);
+    } else {
+        unsigned char buf[5];
+        buf[0] = 0xdd; _msgpack_store32(&buf[1], (uint32_t)n);
+        msgpack_pack_append_buffer(x, buf, 5);
+    }
+}
+
+
+/*
+ * Map
+ */
+
+msgpack_pack_inline_func(_map)(msgpack_pack_user x, size_t n)
+{
+    if(n < 16) {
+        unsigned char d = 0x80 | (uint8_t)n;
+        msgpack_pack_append_buffer(x, &TAKE8_8(d), 1);
+    } else if(n < 65536) {
+        unsigned char buf[3];
+        buf[0] = 0xde; _msgpack_store16(&buf[1], (uint16_t)n);
+        msgpack_pack_append_buffer(x, buf, 3);
+    } else {
+        unsigned char buf[5];
+        buf[0] = 0xdf; _msgpack_store32(&buf[1], (uint32_t)n);
+        msgpack_pack_append_buffer(x, buf, 5);
+    }
+}
+
+
+/*
+ * Str
+ */
+
+msgpack_pack_inline_func(_str)(msgpack_pack_user x, size_t l)
+{
+    if(l < 32) {
+        unsigned char d = 0xa0 | (uint8_t)l;
+        msgpack_pack_append_buffer(x, &TAKE8_8(d), 1);
+    } else if(l < 256) {
+        unsigned char buf[2];
+        buf[0] = 0xd9; buf[1] = (uint8_t)l;
+        msgpack_pack_append_buffer(x, buf, 2);
+    } else if(l < 65536) {
+        unsigned char buf[3];
+        buf[0] = 0xda; _msgpack_store16(&buf[1], (uint16_t)l);
+        msgpack_pack_append_buffer(x, buf, 3);
+    } else {
+        unsigned char buf[5];
+        buf[0] = 0xdb; _msgpack_store32(&buf[1], (uint32_t)l);
+        msgpack_pack_append_buffer(x, buf, 5);
+    }
+}
+
+msgpack_pack_inline_func(_str_body)(msgpack_pack_user x, const void* b, size_t l)
+{
+    msgpack_pack_append_buffer(x, (const unsigned char*)b, l);
+}
+
+/*
+ * Raw (V4)
+ */
+
+msgpack_pack_inline_func(_v4raw)(msgpack_pack_user x, size_t l)
+{
+    if(l < 32) {
+        unsigned char d = 0xa0 | (uint8_t)l;
+        msgpack_pack_append_buffer(x, &TAKE8_8(d), 1);
+    } else if(l < 65536) {
+        unsigned char buf[3];
+        buf[0] = 0xda; _msgpack_store16(&buf[1], (uint16_t)l);
+        msgpack_pack_append_buffer(x, buf, 3);
+    } else {
+        unsigned char buf[5];
+        buf[0] = 0xdb; _msgpack_store32(&buf[1], (uint32_t)l);
+        msgpack_pack_append_buffer(x, buf, 5);
+    }
+}
+
+msgpack_pack_inline_func(_v4raw_body)(msgpack_pack_user x, const void* b, size_t l)
+{
+    msgpack_pack_append_buffer(x, (const unsigned char*)b, l);
+}
+
+/*
+ * Bin
+ */
+
+msgpack_pack_inline_func(_bin)(msgpack_pack_user x, size_t l)
+{
+    if(l < 256) {
+        unsigned char buf[2];
+        buf[0] = 0xc4; buf[1] = (uint8_t)l;
+        msgpack_pack_append_buffer(x, buf, 2);
+    } else if(l < 65536) {
+        unsigned char buf[3];
+        buf[0] = 0xc5; _msgpack_store16(&buf[1], (uint16_t)l);
+        msgpack_pack_append_buffer(x, buf, 3);
+    } else {
+        unsigned char buf[5];
+        buf[0] = 0xc6; _msgpack_store32(&buf[1], (uint32_t)l);
+        msgpack_pack_append_buffer(x, buf, 5);
+    }
+}
+
+msgpack_pack_inline_func(_bin_body)(msgpack_pack_user x, const void* b, size_t l)
+{
+    msgpack_pack_append_buffer(x, (const unsigned char*)b, l);
+}
+
+/*
+ * Ext
+ */
+
+msgpack_pack_inline_func(_ext)(msgpack_pack_user x, size_t l, int8_t type)
+{
+    switch(l) {
+    case 1: {
+        unsigned char buf[2];
+        buf[0] = 0xd4;
+        buf[1] = (unsigned char)type;
+        msgpack_pack_append_buffer(x, buf, 2);
+    } break;
+    case 2: {
+        unsigned char buf[2];
+        buf[0] = 0xd5;
+        buf[1] = (unsigned char)type;
+        msgpack_pack_append_buffer(x, buf, 2);
+    } break;
+    case 4: {
+        unsigned char buf[2];
+        buf[0] = 0xd6;
+        buf[1] = (unsigned char)type;
+        msgpack_pack_append_buffer(x, buf, 2);
+    } break;
+    case 8: {
+        unsigned char buf[2];
+        buf[0] = 0xd7;
+        buf[1] = (unsigned char)type;
+        msgpack_pack_append_buffer(x, buf, 2);
+    } break;
+    case 16: {
+        unsigned char buf[2];
+        buf[0] = 0xd8;
+        buf[1] = (unsigned char)type;
+        msgpack_pack_append_buffer(x, buf, 2);
+    } break;
+    default:
+        if(l < 256) {
+            unsigned char buf[3];
+            buf[0] = 0xc7;
+            buf[1] = (unsigned char)l;
+            buf[2] = (unsigned char)type;
+            msgpack_pack_append_buffer(x, buf, 3);
+        } else if(l < 65536) {
+            unsigned char buf[4];
+            buf[0] = 0xc8;
+            _msgpack_store16(&buf[1], l);
+            buf[3] = (unsigned char)type;
+            msgpack_pack_append_buffer(x, buf, 4);
+        } else {
+            unsigned char buf[6];
+            buf[0] = 0xc9;
+            _msgpack_store32(&buf[1], l);
+            buf[5] = (unsigned char)type;
+            msgpack_pack_append_buffer(x, buf, 6);
+        }
+        break;
+    }
+}
+
+msgpack_pack_inline_func(_ext_body)(msgpack_pack_user x, const void* b, size_t l)
+{
+    msgpack_pack_append_buffer(x, (const unsigned char*)b, l);
+}
+
+msgpack_pack_inline_func(_timestamp)(msgpack_pack_user x, const msgpack_timestamp* d)
+{
+    if ((((int64_t)d->tv_sec) >> 34) == 0) {
+        uint64_t data64 = ((uint64_t) d->tv_nsec << 34) | (uint64_t)d->tv_sec;
+        if ((data64 & 0xffffffff00000000L) == 0)   {
+            // timestamp 32
+            char buf[4];
+            uint32_t data32 = (uint32_t)data64;
+            msgpack_pack_ext(x, 4, -1);
+            _msgpack_store32(buf, data32);
+            msgpack_pack_append_buffer(x, buf, 4);
+        } else {
+            // timestamp 64
+            char buf[8];
+            msgpack_pack_ext(x, 8, -1);
+            _msgpack_store64(buf, data64);
+            msgpack_pack_append_buffer(x, buf, 8);
+        }
+    } else  {
+        // timestamp 96
+        char buf[12];
+        _msgpack_store32(&buf[0], d->tv_nsec);
+        _msgpack_store64(&buf[4], d->tv_sec);
+        msgpack_pack_ext(x, 12, -1);
+        msgpack_pack_append_buffer(x, buf, 12);
+    }
+}
+
+#undef msgpack_pack_inline_func
+#undef msgpack_pack_user
+#undef msgpack_pack_append_buffer
+
+#undef TAKE8_8
+#undef TAKE8_16
+#undef TAKE8_32
+#undef TAKE8_64
+
+#undef msgpack_pack_real_uint8
+#undef msgpack_pack_real_uint16
+#undef msgpack_pack_real_uint32
+#undef msgpack_pack_real_uint64
+#undef msgpack_pack_real_int8
+#undef msgpack_pack_real_int16
+#undef msgpack_pack_real_int32
+#undef msgpack_pack_real_int64
+
+#if defined(_MSC_VER)
+#   pragma warning(pop)
+#endif
diff -ruN fluent-bit-3.2.6-org/lib/msgpack-c/include/msgpack/sysdep.h fluent-bit-3.2.6-new/lib/msgpack-c/include/msgpack/sysdep.h
--- fluent-bit-3.2.6-org/lib/msgpack-c/include/msgpack/sysdep.h	2025-02-11 05:28:17.000000000 +0900
+++ fluent-bit-3.2.6-new/lib/msgpack-c/include/msgpack/sysdep.h	2025-02-17 15:43:47.045504000 +0900
@@ -1,221 +1,221 @@
-/*
- * MessagePack system dependencies
- *
- * Copyright (C) 2008-2010 FURUHASHI Sadayuki
- *
- *    Distributed under the Boost Software License, Version 1.0.
- *    (See accompanying file LICENSE_1_0.txt or copy at
- *    http://www.boost.org/LICENSE_1_0.txt)
- */
-#ifndef MSGPACK_SYSDEP_H
-#define MSGPACK_SYSDEP_H
-
-#include <stdlib.h>
-#include <stddef.h>
-
-#ifndef MSGPACK_ENDIAN_BIG_BYTE
-#define MSGPACK_ENDIAN_BIG_BYTE 0
-#endif
-#ifndef MSGPACK_ENDIAN_LITTLE_BYTE
-#define MSGPACK_ENDIAN_LITTLE_BYTE 1
-#endif
-
-#if defined(_MSC_VER) && _MSC_VER <= 1800
-#   define snprintf(buf, len, format,...) _snprintf_s(buf, len, _TRUNCATE, format, __VA_ARGS__)
-#endif
-
-#if defined(_MSC_VER) && _MSC_VER < 1600
-    typedef signed __int8 int8_t;
-    typedef unsigned __int8 uint8_t;
-    typedef signed __int16 int16_t;
-    typedef unsigned __int16 uint16_t;
-    typedef signed __int32 int32_t;
-    typedef unsigned __int32 uint32_t;
-    typedef signed __int64 int64_t;
-    typedef unsigned __int64 uint64_t;
-#elif defined(_MSC_VER)  // && _MSC_VER >= 1600
-#   include <stdint.h>
-#else
-#   include <stdint.h>
-#   include <stdbool.h>
-#endif
-
-#if !defined(MSGPACK_DLLEXPORT)
-#if defined(_MSC_VER)
-#   define MSGPACK_DLLEXPORT __declspec(dllexport)
-#else  /* _MSC_VER */
-#   define MSGPACK_DLLEXPORT
-#endif /* _MSC_VER */
-#endif
-
-#ifdef _WIN32
-#   if defined(_KERNEL_MODE)
-#       define _msgpack_atomic_counter_header <ntddk.h>
-#   else
-#       define _msgpack_atomic_counter_header <windows.h>
-#       if !defined(WIN32_LEAN_AND_MEAN)
-#           define WIN32_LEAN_AND_MEAN
-#       endif /* WIN32_LEAN_AND_MEAN */
-#   endif
-    typedef long _msgpack_atomic_counter_t;
-#if defined(_AMD64_) || defined(_M_X64) || defined(_M_ARM64)
-#    define _msgpack_sync_decr_and_fetch(ptr) _InterlockedDecrement(ptr)
-#    define _msgpack_sync_incr_and_fetch(ptr) _InterlockedIncrement(ptr)
-#else
-#    define _msgpack_sync_decr_and_fetch(ptr) InterlockedDecrement(ptr)
-#    define _msgpack_sync_incr_and_fetch(ptr) InterlockedIncrement(ptr)
-#endif
-#elif defined(__GNUC__) && ((__GNUC__*10 + __GNUC_MINOR__) < 41)
-
-#   if defined(__cplusplus)
-#       define _msgpack_atomic_counter_header "msgpack/gcc_atomic.hpp"
-#   else
-#       define _msgpack_atomic_counter_header "msgpack/gcc_atomic.h"
-#   endif
-
-#else
-    typedef unsigned int _msgpack_atomic_counter_t;
-#   define _msgpack_sync_decr_and_fetch(ptr) __sync_sub_and_fetch(ptr, 1)
-#   define _msgpack_sync_incr_and_fetch(ptr) __sync_add_and_fetch(ptr, 1)
-#endif
-
-#ifdef _WIN32
-
-#   ifdef __cplusplus
-    /* numeric_limits<T>::min,max */
-#       ifdef max
-#           undef max
-#       endif
-#       ifdef min
-#           undef min
-#       endif
-#   endif
-
-#elif defined(unix) || defined(__unix) || defined(__APPLE__) || defined(__OpenBSD__)
-
-#include <arpa/inet.h>  /* __BYTE_ORDER */
-#   if defined(linux)
-#       include <byteswap.h>
-#   endif
-
-#endif
-
-#if !defined(MSGPACK_ENDIAN_LITTLE_BYTE) && !defined(MSGPACK_ENDIAN_BIG_BYTE)
-#include <msgpack/predef/other/endian.h>
-#endif // !defined(MSGPACK_ENDIAN_LITTLE_BYTE) && !defined(MSGPACK_ENDIAN_BIG_BYTE)
-
-#if MSGPACK_ENDIAN_LITTLE_BYTE
-
-#   if defined(unix) || defined(__unix) || defined(__APPLE__) || defined(__OpenBSD__)
-#       define _msgpack_be16(x) ntohs((uint16_t)x)
-#   else
-#       if defined(ntohs)
-#           define _msgpack_be16(x) ntohs(x)
-#       elif defined(_byteswap_ushort) || (defined(_MSC_VER) && _MSC_VER >= 1400)
-#           define _msgpack_be16(x) ((uint16_t)_byteswap_ushort((unsigned short)x))
-#       else
-#           define _msgpack_be16(x) ( \
-                ((((uint16_t)x) <<  8) ) | \
-                ((((uint16_t)x) >>  8) ) )
-#        endif
-#   endif
-
-#   if defined(unix) || defined(__unix) || defined(__APPLE__) || defined(__OpenBSD__)
-#       define _msgpack_be32(x) ntohl((uint32_t)x)
-#   else
-#       if defined(ntohl)
-#           define _msgpack_be32(x) ntohl(x)
-#       elif defined(_byteswap_ulong) || (defined(_MSC_VER) && _MSC_VER >= 1400)
-#           define _msgpack_be32(x) ((uint32_t)_byteswap_ulong((unsigned long)x))
-#       else
-#           define _msgpack_be32(x) \
-                ( ((((uint32_t)x) << 24)               ) | \
-                  ((((uint32_t)x) <<  8) & 0x00ff0000U ) | \
-                  ((((uint32_t)x) >>  8) & 0x0000ff00U ) | \
-                  ((((uint32_t)x) >> 24)               ) )
-#       endif
-#   endif
-
-#   if defined(_byteswap_uint64) || (defined(_MSC_VER) && _MSC_VER >= 1400)
-#        define _msgpack_be64(x) (_byteswap_uint64(x))
-#   elif defined(bswap_64)
-#        define _msgpack_be64(x) bswap_64(x)
-#   elif defined(__DARWIN_OSSwapInt64)
-#        define _msgpack_be64(x) __DARWIN_OSSwapInt64(x)
-#   else
-#        define _msgpack_be64(x) \
-             ( ((((uint64_t)x) << 56)                         ) | \
-               ((((uint64_t)x) << 40) & 0x00ff000000000000ULL ) | \
-               ((((uint64_t)x) << 24) & 0x0000ff0000000000ULL ) | \
-               ((((uint64_t)x) <<  8) & 0x000000ff00000000ULL ) | \
-               ((((uint64_t)x) >>  8) & 0x00000000ff000000ULL ) | \
-               ((((uint64_t)x) >> 24) & 0x0000000000ff0000ULL ) | \
-               ((((uint64_t)x) >> 40) & 0x000000000000ff00ULL ) | \
-               ((((uint64_t)x) >> 56)                         ) )
-#   endif
-
-#elif MSGPACK_ENDIAN_BIG_BYTE
-
-#   define _msgpack_be16(x) (x)
-#   define _msgpack_be32(x) (x)
-#   define _msgpack_be64(x) (x)
-
-#else
-#   error msgpack-c supports only big endian and little endian
-#endif /* MSGPACK_ENDIAN_LITTLE_BYTE */
-
-#define _msgpack_load16(cast, from, to) do {       \
-        memcpy((cast*)(to), (from), sizeof(cast)); \
-        *(to) = (cast)_msgpack_be16(*(to));      \
-    } while (0);
-
-#define _msgpack_load32(cast, from, to) do {       \
-        memcpy((cast*)(to), (from), sizeof(cast)); \
-        *(to) = (cast)_msgpack_be32(*(to));        \
-    } while (0);
-#define _msgpack_load64(cast, from, to) do {       \
-        memcpy((cast*)(to), (from), sizeof(cast)); \
-        *(to) = (cast)_msgpack_be64(*(to));        \
-    } while (0);
-
-#define _msgpack_store16(to, num) \
-    do { uint16_t val = _msgpack_be16(num); memcpy(to, &val, 2); } while(0)
-#define _msgpack_store32(to, num) \
-    do { uint32_t val = _msgpack_be32(num); memcpy(to, &val, 4); } while(0)
-#define _msgpack_store64(to, num) \
-    do { uint64_t val = _msgpack_be64(num); memcpy(to, &val, 8); } while(0)
-
-/*
-#define _msgpack_load16(cast, from) \
-    ({ cast val; memcpy(&val, (char*)from, 2); _msgpack_be16(val); })
-#define _msgpack_load32(cast, from) \
-    ({ cast val; memcpy(&val, (char*)from, 4); _msgpack_be32(val); })
-#define _msgpack_load64(cast, from) \
-    ({ cast val; memcpy(&val, (char*)from, 8); _msgpack_be64(val); })
-*/
-
-
-#if !defined(__cplusplus) && defined(_MSC_VER)
-#  if !defined(_KERNEL_MODE)
-#    if !defined(FALSE)
-#      define FALSE (0)
-#    endif
-#    if !defined(TRUE)
-#      define TRUE (!FALSE)
-#    endif
-#  endif
-#  if _MSC_VER >= 1800
-#    include <stdbool.h>
-#  else
-#    define bool int
-#    define true TRUE
-#    define false FALSE
-#  endif
-#  define inline __inline
-#endif
-
-#ifdef __APPLE__
-#  include <TargetConditionals.h>
-#endif
-
-#endif /* msgpack/sysdep.h */
+/*
+ * MessagePack system dependencies
+ *
+ * Copyright (C) 2008-2010 FURUHASHI Sadayuki
+ *
+ *    Distributed under the Boost Software License, Version 1.0.
+ *    (See accompanying file LICENSE_1_0.txt or copy at
+ *    http://www.boost.org/LICENSE_1_0.txt)
+ */
+#ifndef MSGPACK_SYSDEP_H
+#define MSGPACK_SYSDEP_H
+
+#include <stdlib.h>
+#include <stddef.h>
+
+#ifndef MSGPACK_ENDIAN_BIG_BYTE
+#define MSGPACK_ENDIAN_BIG_BYTE 0
+#endif
+#ifndef MSGPACK_ENDIAN_LITTLE_BYTE
+#define MSGPACK_ENDIAN_LITTLE_BYTE 1
+#endif
+
+#if defined(_MSC_VER) && _MSC_VER <= 1800
+#   define snprintf(buf, len, format,...) _snprintf_s(buf, len, _TRUNCATE, format, __VA_ARGS__)
+#endif
+
+#if defined(_MSC_VER) && _MSC_VER < 1600
+    typedef signed __int8 int8_t;
+    typedef unsigned __int8 uint8_t;
+    typedef signed __int16 int16_t;
+    typedef unsigned __int16 uint16_t;
+    typedef signed __int32 int32_t;
+    typedef unsigned __int32 uint32_t;
+    typedef signed __int64 int64_t;
+    typedef unsigned __int64 uint64_t;
+#elif defined(_MSC_VER)  // && _MSC_VER >= 1600
+#   include <stdint.h>
+#else
+#   include <stdint.h>
+#   include <stdbool.h>
+#endif
+
+#if !defined(MSGPACK_DLLEXPORT)
+#if defined(_MSC_VER)
+#   define MSGPACK_DLLEXPORT __declspec(dllexport)
+#else  /* _MSC_VER */
+#   define MSGPACK_DLLEXPORT
+#endif /* _MSC_VER */
+#endif
+
+#ifdef _WIN32
+#   if defined(_KERNEL_MODE)
+#       define _msgpack_atomic_counter_header <ntddk.h>
+#   else
+#       define _msgpack_atomic_counter_header <windows.h>
+#       if !defined(WIN32_LEAN_AND_MEAN)
+#           define WIN32_LEAN_AND_MEAN
+#       endif /* WIN32_LEAN_AND_MEAN */
+#   endif
+    typedef long _msgpack_atomic_counter_t;
+#if defined(_AMD64_) || defined(_M_X64) || defined(_M_ARM64)
+#    define _msgpack_sync_decr_and_fetch(ptr) _InterlockedDecrement(ptr)
+#    define _msgpack_sync_incr_and_fetch(ptr) _InterlockedIncrement(ptr)
+#else
+#    define _msgpack_sync_decr_and_fetch(ptr) InterlockedDecrement(ptr)
+#    define _msgpack_sync_incr_and_fetch(ptr) InterlockedIncrement(ptr)
+#endif
+#elif defined(__GNUC__) && ((__GNUC__*10 + __GNUC_MINOR__) < 41)
+
+#   if defined(__cplusplus)
+#       define _msgpack_atomic_counter_header "msgpack/gcc_atomic.hpp"
+#   else
+#       define _msgpack_atomic_counter_header "msgpack/gcc_atomic.h"
+#   endif
+
+#else
+    typedef unsigned int _msgpack_atomic_counter_t;
+#   define _msgpack_sync_decr_and_fetch(ptr) __sync_sub_and_fetch(ptr, 1)
+#   define _msgpack_sync_incr_and_fetch(ptr) __sync_add_and_fetch(ptr, 1)
+#endif
+
+#ifdef _WIN32
+
+#   ifdef __cplusplus
+    /* numeric_limits<T>::min,max */
+#       ifdef max
+#           undef max
+#       endif
+#       ifdef min
+#           undef min
+#       endif
+#   endif
+
+#elif defined(unix) || defined(__unix) || defined(__APPLE__) || defined(__OpenBSD__)
+
+#include <arpa/inet.h>  /* __BYTE_ORDER */
+#   if defined(linux)
+#       include <byteswap.h>
+#   endif
+
+#endif
+
+#if !defined(MSGPACK_ENDIAN_LITTLE_BYTE) && !defined(MSGPACK_ENDIAN_BIG_BYTE)
+#include <msgpack/predef/other/endian.h>
+#endif // !defined(MSGPACK_ENDIAN_LITTLE_BYTE) && !defined(MSGPACK_ENDIAN_BIG_BYTE)
+
+#if MSGPACK_ENDIAN_LITTLE_BYTE
+
+#   if defined(unix) || defined(__unix) || defined(__APPLE__) || defined(__OpenBSD__)
+#       define _msgpack_be16(x) ntohs((uint16_t)x)
+#   else
+#       if defined(ntohs)
+#           define _msgpack_be16(x) ntohs(x)
+#       elif defined(_byteswap_ushort) || (defined(_MSC_VER) && _MSC_VER >= 1400)
+#           define _msgpack_be16(x) ((uint16_t)_byteswap_ushort((unsigned short)x))
+#       else
+#           define _msgpack_be16(x) ( \
+                ((((uint16_t)x) <<  8) ) | \
+                ((((uint16_t)x) >>  8) ) )
+#        endif
+#   endif
+
+#   if defined(unix) || defined(__unix) || defined(__APPLE__) || defined(__OpenBSD__)
+#       define _msgpack_be32(x) ntohl((uint32_t)x)
+#   else
+#       if defined(ntohl)
+#           define _msgpack_be32(x) ntohl(x)
+#       elif defined(_byteswap_ulong) || (defined(_MSC_VER) && _MSC_VER >= 1400)
+#           define _msgpack_be32(x) ((uint32_t)_byteswap_ulong((unsigned long)x))
+#       else
+#           define _msgpack_be32(x) \
+                ( ((((uint32_t)x) << 24)               ) | \
+                  ((((uint32_t)x) <<  8) & 0x00ff0000U ) | \
+                  ((((uint32_t)x) >>  8) & 0x0000ff00U ) | \
+                  ((((uint32_t)x) >> 24)               ) )
+#       endif
+#   endif
+
+#   if defined(_byteswap_uint64) || (defined(_MSC_VER) && _MSC_VER >= 1400)
+#        define _msgpack_be64(x) (_byteswap_uint64(x))
+#   elif defined(bswap_64)
+#        define _msgpack_be64(x) bswap_64(x)
+#   elif defined(__DARWIN_OSSwapInt64)
+#        define _msgpack_be64(x) __DARWIN_OSSwapInt64(x)
+#   else
+#        define _msgpack_be64(x) \
+             ( ((((uint64_t)x) << 56)                         ) | \
+               ((((uint64_t)x) << 40) & 0x00ff000000000000ULL ) | \
+               ((((uint64_t)x) << 24) & 0x0000ff0000000000ULL ) | \
+               ((((uint64_t)x) <<  8) & 0x000000ff00000000ULL ) | \
+               ((((uint64_t)x) >>  8) & 0x00000000ff000000ULL ) | \
+               ((((uint64_t)x) >> 24) & 0x0000000000ff0000ULL ) | \
+               ((((uint64_t)x) >> 40) & 0x000000000000ff00ULL ) | \
+               ((((uint64_t)x) >> 56)                         ) )
+#   endif
+
+#elif MSGPACK_ENDIAN_BIG_BYTE
+
+#   define _msgpack_be16(x) (x)
+#   define _msgpack_be32(x) (x)
+#   define _msgpack_be64(x) (x)
+
+#else
+#   error msgpack-c supports only big endian and little endian
+#endif /* MSGPACK_ENDIAN_LITTLE_BYTE */
+
+#define _msgpack_load16(cast, from, to) do {       \
+        memcpy((cast*)(to), (from), sizeof(cast)); \
+        *(to) = (cast)_msgpack_be16(*(to));      \
+    } while (0);
+
+#define _msgpack_load32(cast, from, to) do {       \
+        memcpy((cast*)(to), (from), sizeof(cast)); \
+        *(to) = (cast)_msgpack_be32(*(to));        \
+    } while (0);
+#define _msgpack_load64(cast, from, to) do {       \
+        memcpy((cast*)(to), (from), sizeof(cast)); \
+        *(to) = (cast)_msgpack_be64(*(to));        \
+    } while (0);
+
+#define _msgpack_store16(to, num) \
+    do { uint16_t val = _msgpack_be16(num); memcpy(to, &val, 2); } while(0)
+#define _msgpack_store32(to, num) \
+    do { uint32_t val = _msgpack_be32(num); memcpy(to, &val, 4); } while(0)
+#define _msgpack_store64(to, num) \
+    do { uint64_t val = _msgpack_be64(num); memcpy(to, &val, 8); } while(0)
+
+/*
+#define _msgpack_load16(cast, from) \
+    ({ cast val; memcpy(&val, (char*)from, 2); _msgpack_be16(val); })
+#define _msgpack_load32(cast, from) \
+    ({ cast val; memcpy(&val, (char*)from, 4); _msgpack_be32(val); })
+#define _msgpack_load64(cast, from) \
+    ({ cast val; memcpy(&val, (char*)from, 8); _msgpack_be64(val); })
+*/
+
+
+#if !defined(__cplusplus) && defined(_MSC_VER)
+#  if !defined(_KERNEL_MODE)
+#    if !defined(FALSE)
+#      define FALSE (0)
+#    endif
+#    if !defined(TRUE)
+#      define TRUE (!FALSE)
+#    endif
+#  endif
+#  if _MSC_VER >= 1800
+#    include <stdbool.h>
+#  else
+#    define bool int
+#    define true TRUE
+#    define false FALSE
+#  endif
+#  define inline __inline
+#endif
+
+#ifdef __APPLE__
+#  include <TargetConditionals.h>
+#endif
+
+#endif /* msgpack/sysdep.h */
